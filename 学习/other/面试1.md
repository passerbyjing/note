## ***2020最新面试宝典页面版***

 

***前端开发面试知识点大纲：***

***\*HTML&CSS：\****

***\*对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应\****

***\*JavaScript：\****

***\*数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等。\****

***\*其他：\****

***\*HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯\****

***\*作为一名前端工程师，无论工作年头长短都应该必须掌握的知识点\****

## ***如何描述自己做过的项目***

###### ***开篇***

~~~
在面试时，经过寒暄后，一般面试官会让介绍项目经验 。常见的问法是，说下你最近的（或最拿得出手的）一个项目。
根据我们的面试经验，发现有不少候选人对此没准备，说起来磕磕巴巴，甚至有人说出项目经验从时间段或技术等方面和简历上的不匹配，这样就会造成如下的后果。
1. 第一印象就不好了，至少会感觉该候选人表述能力不强。
2. 一般来说，面试官会根据候选人介绍的项目背景来提问题，假设面试时会问10个问题，那么至少有5个问题会根据候选人所介绍的项目背景来问，候选人如果没说好，那么就没法很好地引导后继问题了，就相当于把提问权完全交给面试官了。
面试时7份靠能力，3份靠技能，而刚开始时的介绍项目又是技能中的重中之重，所以本文将从“介绍”和“引导”两大层面告诉大家如何准备面试时的项目介绍。
~~~

###### ***1、在面试前准备项目描述，别害怕，因为面试官什么都不知道***

~~~
面试官是人，不是神，拿到你的简历的时候，是没法核实你的项目细节的（一般公司会到录用后，用背景调查的方式来核实）。
更何况，你做的项目是以月为单位算的，而面试官最多用30分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度要远远超过面试官，所以你一点也不用紧张。
如果你的工作经验比面试官还丰富的话，甚至还可以控制整个面试流程（笔者在面试方面成精后也经常干这种事情，大家一定也能行）。
既然面试官无法了解你的底细，那么他们怎么来验证你的项目经验和技术？
~~~

###### ***2、准备项目的各种细节，一旦被问倒了，就说明你没做过***

~~~
一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。而且这些是你实际的项目经验（不是学习经验，也不是培训经验），那么一旦让面试官感觉你都说不上来，那么可信度就很低了。
不少人是拘泥于“项目里做了什么业务，以及代码实现的细节”，这就相当于把后继提问权直接交给面试官。下表列出了一些不好的回答方式。
在避免上述不好的回答的同时，大家可以按下表所给出的要素准备项目介绍。如果可以，也请大家准备一下用英语描述。其实刚毕业的学生，或者工作经验较少的人，英语能力都差不多，但你说了，这就是质的进步。   
~~~

###### ***3、不露痕迹地说出面试官爱听的话***

~~~
在项目介绍的时候（当然包括后继的面试），面试官其实很想要听一些关键点，只要你说出来，而且回答相关问题比较好，这绝对是加分项。我在面试别人的时候，一旦这些关键点得到确认，我是绝对会在评语上加上一笔的。
~~~

###### ***4、一定要主动，面试官没有义务挖掘你的亮点***

~~~
我去面试人家的时候，往往会特别提问：你项目里有什么亮点？或者你作为应聘者，有什么其他加分项能帮你成功应聘到这个岗位。即使这样问，还有些人直接说没有。我这样问已经是处于角色错位了，作为面试者，应当主动说出，而不是等着问，但请注意，说的时候要有技巧，找机会说，通常是找一些开放性的问题说。或者找个相关的问题做扩展性说明，比如被问到：你有没有用到过一对多和多对多？你除了说基本知识点以外，还可以说，一般我还会根据需求适当地设置cascade和inverse关键字，随后通过一个实际的案例来说明合理设计对你项目的帮助，这样就能延伸性地说明你的技能了。相反如果你不说，面试话一定会认为你只会简单的一对一和一对多操作。

面试的时候，如果候选人回答问题很简单，有一说一，不会扩展，或者用非常吝啬的语句来回答我的问题，那么我一般会给机会让他们深入讲述（但我不敢保证不是每个面试官都会深入提问），如果回答再简洁，那么也会很吝啬地给出好的评语。
记住：面试官不是你的亲戚，面试官很忙，能挖掘出你的亮点的面试官很少，而说出你的亮点是你的义务。
我在面试别人过程中，根据不同的情况一般会给出如下的评语。
1、回答很简答，但回答里能证明出他对框架等技术确实是做过，我会在评语里些“对框架了解一般，不知道一些深层次的知识（我都问了多次了你都回答很简答，那么对不起了，我只能这么写，或许你确实技术很强，那也没办法，谁让你不肯说呢？）”，同时会加一句“表达能力很一般，沟通能力不强”，这样即使他通过技术面试，后面的面试他也会很吃力。
2、回答很简单，通过回答我没法验证他是在项目里做过这个技术，还是仅仅在平时学习中学过这个技术。我就会写“在简历中说用过XX技术，但对某些细节说不上来，没法看出在项目里用到这个技术”，如果这个技术是职务必需点，那么他通过面试的可能性就非常小。
3、回答很简单，而且只通过嗯啊之类的虚词回答，经过提醒还这样，我会敷衍几句结束面试，直接写“技术很薄弱，没法通过面试”。
4、虽然通过回答能很好地展示自己的技能，但逻辑调理不清晰，那么我会让他通过技术面试，但会写上“技能很好，但表达能力一般（或有待提高），请后继面试经理斟酌”。这样通过后继综合面试的机会就一般了，毕竟综合面试会着重考察表达能力交往能力等非技术因素。
不管怎样，一旦回答简单，不主动说出你的擅长点，或没有条理很清楚地说出你的亮点，就算我让你通过面试，也不会写上“框架细节了解比较深，数据库应用比较熟练”等之类的好评语，你即使通过技术和后面的综合面试，工资也是比较低的。
5、一旦有低级错误，可能会直接出局
面试过程中有些方面你是绝对不能出错，所以你在准备过程中需要尤其注意如下的因素。下面列了些会导致你直接出局的错误回答。
6、引导篇：准备些加分点，在介绍时有意提到，但别说全在做项目介绍的时候，你可以穿插说出一些你的亮点，但请记得，不论在介绍项目还是在回答问题，你当前的职责不是说明亮点而是介绍项目，一旦你详细说，可能会让面试官感觉你跑题了。
所以这时你可以一笔带过，比如你可以说，“我们的项目对数据要求比较大，忙的时候平均每小时要处理几十万条数据”，这样就可以把面试官引入“大数据”的方向。
你在面试前可以根据职位的需求，准备好这种“一笔带过”的话。比如这个职位的需求点是VUE MVVM框架，商城类型项目，要有数据优化兼容经验，那么介绍以往项目时，你就最好突出这些方面你的实际技能。
实在不行，你也可以说“我除了做开发，也做了了解需求，测试和部署的工作，因为这个项目人手比较少，压力比较大”，这样你也能展示你有过独挡一面的经历。
在面试过程中，一旦听到有亮点，就会等到他说好当前问题后，顺口去问，一般技术面试最多办半小时，你把时间用在回答准备好的问题点上的时候，被问其他问题的时间就会少了。
~~~

###### ***7、你可以引导，但不能自说自话***

~~~
我面试的时候，也会遇到些有准备的人，其实如果你真的想应聘的话，一定要事先准备，这点我能理解，甚至赞同，你只要别露出太明显的痕迹，我不会写上“似乎有准备，没法考察真实技能”这种话，更何况未必每个面试官都能感觉出你准备过。 但你不能凭着有准备而太强势，毕竟面试是面试官主导的。
我遇到个别面试的人，他们说话太多，一般会主动扩展，比如我问他数据库用什么，他不仅回答数据库是什么，自己做了什么，甚至顺便会把大数据处理技术都说出来。
其实过犹不及，我就会重点考察你说的每个细节，因为我怀疑你说的都是你从网上看的，而不是你项目中用到的，我甚至会直接威胁：“你先和我说实话这个技术你真在项目里用到，我后面会重点考察，一旦被认为你项目里没做，这个性质就是蒙混过关了”，往往这些人会主动坦白。
不过话说回来，他如果仅仅说，数据量比较大，但点到为止，不继续说后面的话，我就会深入去问，他自然有机会表达。同时请注意，一般在面试过程中，一旦你亮出加分点，但面试官没接嘴，这个加分点可能就不是项目必备的，也不是他所关注的，当前你就可以别再说了，或者等到你提问题的时候再说。   
~~~

## ***兼容性***

##### ***（一）html部分***

###### **1.H5新标签在IE9以下的浏览器识别 **

~~~js
<!--[if lt IE 9]>
 <script type="text/javascript" src="js/html5shiv.js"></script>
<![endif]-->
 html5shiv.js下载地址
~~~

###### **2.ul标签内外边距问题ul标签在IE6\IE7中，有个默认的外边距，但是在IE8以上及其他浏览器中有个默认的内边距。解决方法：统一设置ul的内外边距为**

###### ***（二）CSS样式的兼容性***   

###### **1.css的hack问题：主要针对IE的不同版本，不同的浏览器的写法不同**   

~~~js
 <!--[if IE 6]>此处内容只有IE6.0可见<![endif]-->     
 <!--[if IE 7]>此处内容只有IE7.0可见<![endif]-->
~~~

###### **2.IE6双边距问题：IE6在浮动后，又有横向的margin，此时，该元素的外边距是其值的2倍**

~~~
display:block;
~~~

###### **3.IE6下图片的下方有空隙**   

~~~
给img设置display:block;
~~~

###### **4.IE6下两个float之间会有个3px的bug**    

 ~~~
 给右边的元素也设置float:left;
 ~~~

###### **5.IE6下没有min-width的概念，其默认的width就是min-width**

###### **6.IE6下在使用margin:0 auto;无法使其居中**    

 ~~~
 为其父容器设置text-align:center;
 ~~~

**7.被点击过后的超链接不再具有hover和active属性**

~~~
 解决办法:按lvha的顺序书写css样式，
 ":link": a标签还未被访问的状态；
 ":visited": a标签已被访问过的状态；
 ":hover": 鼠标悬停在a标签上的状态；
 ":active": a标签被鼠标按着时的状态；
~~~

###### **8.在使用绝对定位或者相对定位后，IE中设置z-index失效，原因是因为其元素依赖于父元素的z-index，但是父元素默认为0， 子高父低，所以不会改变显示的顺序**

###### **9.IE6下无法设置1px的行高，原因是由其默认行高引起的**    

~~~
为其设置overflow:hidden;或者line-height:1px;
~~~

***（三）JavaScript的兼容性***

###### **1.标准的事件绑定方法函数为addEventListener，但IE下是attachEvent；**

###### **2.事件的捕获方式不一致，标准浏览器是由外至内，而IE是由内到外，但是最后的结果是将IE的标准定为标准**

###### **3.window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement**

###### **4.在低版本的IE中获取的日期处理函数的值不是与1900的差值，但是在高版本的IE中和标准浏览器保持了一致，获取的值也是与1900的差值。**     

~~~
var year= new Date().getYear();
~~~

###### **5.ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject**

###### **6.IE中不能操作tr的innerHtml**

###### **7.获得DOM节点的父节点、子节点的方式不同**

~~~
其他浏览器：parentNode parentNode.childNodes    
IE：parentElement parentElement.childre
~~~

## ***小程序***

###### **1.数据请求怎么封装**

~~~
- 将所有的接口放在统一的js文件中并导出（或者将请求地址、头、方法在一个js文件里统一定义为一个常量并导出）
- 在app.js创建封装请求数据的方法
- 在子页面中调用封装的方法请求数据
~~~

###### **2.参数传值的方法**

~~~
- 给HTML元素中添加data-*属性来传递需要的值，之后通过e.currentTarget.dataset或onload的param参数获取。注意不能有大写字母，不可以存放对象
- 跳转页面时通过navigator传递需要的参数值
- 设置id的方法标识，通过e.currentTarget.id获取设置的id值，然后通过设置全局变量的方法来传递数值
~~~

###### **3.提高小程序的应用速度的方法**

~~~
- 减少默认data的大小
- 组件化方案，公用的如弹框等写个自定义的组件，然后调用
~~~

###### **4.小程序的优点**

~~~
- 无需下载
- 打开速度快
- 开发成本低
- 为用户提供良好的安全保障。发布有一套严格的审查流程，不能通过审查的程序无法发布上线
- 服务请求快
~~~

###### **5.小程序的缺点**

~~~
- 依托微信，不能开发后台管理功能
- 大小限制不能超过2M，不能打开超过5个层级的页面
~~~

###### **6.简述小程序原理**

~~~
- 小程序分为两个部分webview和appService，webview用来展现UI，appService用来处理业务逻辑、数据及接口调用，它们在两个进程中运行，通过系统层JSBridge实现通信，完成UI渲染、事件处理。
~~~

###### **7.怎么解决异步请求问题**

~~~
- <1>不封装接口的话可以在返回成功的回调里面处理逻辑
- <2>可以用Promise 来封装
- <3>可以引用runtime来使用async await
- <4>使用wepy或着美团的小程序框架，可以通过安装库解决
- <5>在回调函数中调用下一个组件的函数
~~~

###### **webview中的页面怎么跳回小程序中**

 先在管理后台配置域名白名单，

然后引入jweixin-1.3.2.js（https://res.wx.qq.com/open/js/jweixin-1.3.0.js），最后

wx.miniProgram.navigateTo({url: '/pages/login/login'+'$params'})

wx.miniProgram.navigateTo({url: '/path/to/page'})

webview的页面怎么跳转到小程序导航的页面？

小程序导航的页面可以通过switchTab，但默认情况是不会重新加载数据的。若需加载新数据，则在success属性中加入以下代码即可：

success: function (e) {

​      var page = getCurrentPages().pop();

​      if (page == undefined || page == null) return，

​      page.onLoad();

​     }

webview的页面，则通过

 wx.miniProgram.switchTab({

​     url: '/pages/index/index'

​    })

###### ***\*7.小程序和Vue写法的区别\****

循环遍历：小程序是wx:for="list"，vue是v-for="inforin list"

调用data模型：小程序是this.data.unifo，vue是this.unifo

给模型赋值：小程序是this.setData({unifo:1})，vue是直接this.unifo=1

###### ***\*8.小程序的双向绑定和vue哪里不一样\****

小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData({})

###### ***\*1px = 2rpx\****

###### ***\*9.生命周期函数\****

onLoad——页面加载，调一次

onShow——页面显示，每次打开页面都调用

onReady——初次渲染完成，调一次

onHide——页面隐藏，当navigateTo或底部tab切换时调用

onUnload——页面卸载，当redirectTo或navigateBack时调用

###### ***\*10.几种跳转，小程序内的页面跳转\****

wx.navigateTo——保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面（参数必须为字符串）

wx.redirectTo——关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面

wx.switchTab——跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，路径后不能带参数

wx.navigateBack——关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层

wx.reLaunch——关闭所有页面，打开到应用内的某个页面

通过navigator跳转

###### ***\*11.如何自定义组件\****

先创建一个components文件夹，用来存放所有自定义组件的，目录结构依然是js,wxml,json,wxss

基本配置：

.json——进行自定义组件声明

{

 "component": true

}

使用组件：

假如在index.wxml中使用这个自定义的组件，首先在index.json中进行声明

{  

 "usingComponents": {  

   "toastdemo": "/components/toastdemo/toastdemo"  

 }  

}

接着在index.wxml中引用

然后在index.js进行配置

使用时直接执行this.toastdemo.showToast('弹框组件调用成功',2000)就可以了

###### ***\*12.如何实现下拉刷新\****

先在app.json或page.json中配置enablePullDownRefresh:true

page里用onPullDownRefresh函数，在下拉刷新时执行

在下拉函数执行时发起数据请求，请求返回后，调用wx.stopPullDownRefresh停止下拉刷新的状态

###### ***\*bindtap和catchtap的区别是什么\****

bindtap不会阻止冒泡事件，catchtap阻止冒泡

###### ***\*13.setData的回调函数\****

微信小程序的setData实现是和react的setData实现类似的，所以它也是一个异步函数，并且有回调函数的参数，当然平时小量数据我们可能并没有感觉到它的异步，但是为了确保逻辑的正确执行，在需要用到setData后 data里的数据的步骤，请写入setData的回调函数中，如下示例：

this.setData({

 a: this.data.a++

 },()=>{

})

###### ***\*14.小程序和小程序之间的跳转\****

在同一主体公众号上关联2个小程序appid，

用navigator，对应设置一些属性即可

target：miniProgram——其他小程序

target：self——当前小程序

###### ***\*15.小程序顶部自定义导航怎么写\****

原生导航栏

自定义导航栏：在app.json的window对象中定义导航的样式navigationStyle："custom"

https://www.cnblogs.com/jiangbeixiaoqiao/p/10826291.html

###### ***\*16.小程序的单向数据绑定\****

{{属性名}}，this.setData{{}}setdata和页面数据的线程机制

多线程Worker：执行多条并行线程，

https://blog.csdn.net/weixin_40440167/article/details/78386412?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

1.https://www.jb51.net/article/165372.htm

2.https://www.cnblogs.com/idreamo/p/10853965.html

3.https://developers.weixin.qq.com/miniprogram/dev/api/worker/Worker.html

###### ***\*17.分包的操作，发布的时候是选择某个包来发吗\****

分包：主包添加跳转路径，分包放内容，在app.json配置subpakeages声明项目分包结构。代码包总包大小为12M，单个主包/分包大小不能超过2M。

按照功能划分的打包原则：可以按照功能的划分，拆分成几个分包，当需要用到某个功能时，才加载这个功能对应的分包；公共逻辑、组件放在主包内。

首次启动时，先下载小程序主包，显示主包内的页面；如果进入了某个分包的页面，再下载这个对应分包，下载完毕后，显示分包的页面，

总结：首先配置好打包路径，tabbar页面必须在主包内。各分包之间不能互相调用，能调用主包内的

分包加载，预分包加载

###### ***\*18.同时setdata很多数据，对性能有什么影响\****

import是es的还是node的，怎么使用npm install了的文件

npm run dev的dev是怎么设置的

###### ***\*19.小程序的微信支付是哪个API，参数是哪些及怎么获取的\****

wx.requestPayment

###### ***\*20.说几个常用的API\****

wx.login

wx.request

wx.navigateTo

wx.redirectTo

wx.switchTab

wx.naviageteBack

wx.reLaunch

等等…

###### ***\*21.授权验证登录怎么做，用户退出后下次进入还需要再次授权吗\****

wx.login获取到一个code，拿这code去请求后台得到openId, sessionKey, unionId。

调wx.getUserInfo

一次性授权：

永久授权：调取授权登录接口并把获取到的用户公开信息存入数据库

22.小程序有常用的UI库吗，是什么

WeUI，可按需下载，把下载的压缩好放入项目里，项目目录为weui-miniprogram。

https://developers.weixin.qq.com/miniprogram/dev/extended/weui/download.html

###### ***\*23.验证授权是自动弹出还是触发的\****

按钮触发的，open-type指定为getUserInfo类型

24.小程序页面间有哪些传递数据的方法

使用全局变量实现数据传递：在app.js文件中定义全局变量globalData，将需要存储的信息存放在里面：

// app.js

 

App({

   // 全局变量

 globalData: {

  userInfo: null

 }

})

使用的时候，直接使用getApp()拿到存储的信息

使用wx.navigateTo和wx.redirectTo的时候，可以将部分数据放在url里，并在新页面onLoad的时候初始化

###### ***\*25.小程序网络请求封装\****

网络请求小程序提供了wx.request

https://segmentfault.com/a/1190000014789969

###### ***\*26.怎么解决小程序的异步请求问题\****

小程序支持大部分es6语法：在返回成功的回调里面处理逻辑；Promise异步

###### ***\*27.小程序关联微信公众号如何确定用户的唯一性\****

unionid是相同且唯一的

###### ***\*28.如何实现下拉刷新\****

首先在全局config中的window配置enablePullDownRefresh

###### ***\*30.小程序页面见传值的方式有几种\****

url（跳转）

storage（wx.storageSync）

全局变量（getApp）

## ***\*开发中遇到的BUG\****

##### ***\*前端开发过程中经常遇到的bug的问题以及应对方法（持续更新）\****

###### ***\*1：vue项目中用v-for 循环本地图片， 图片不显示，解决办法：使用require动态引入图片，或将图片放static文件夹里面\****

<img v-bind:src="require(item.imgurl)">

###### ***\*2:合并多个对象并去重（es6）\****

let objOne = {a:1};

  let objTwo = {b:2};

  let objThree = {b:4,c:5};

  let obj = Object.assign(objOne,objTwo,objThree);

  console.log(obj)   // {a:1,b:4,c:5}

​	let obj1={...objOne,...objTwo,...objThree};

  console.log(obj1)  // {a:1,b:4,c:5}

###### ***\*3:vue计算属性里如何传参：需求是需要把数值转为三位数，类似1需要变为001，10变为010这样。 下面是正确写法，页面中用{{convertToThree(num1)}}，{{convertToThree(num2)}}，{{convertToThree(num3)}}即可获得对应三位数的模样：\****

new Vue({

  el:'#app',

  data:{

​    num1:0,

​    num2:10,

​    num3:100

  },

  computed:{

​    convertToThree:function(){

​      return function(num){

​         if(num>=0 && num <=9){

​          return '00' + num

​         }else if(num>=10 && num <=99){

​          return '0' + num

​         }

​          return num

​        }  

​    }

  }

})

###### ***\*4:JS监听同源其他窗口发生的事件，主要是利用 window.addEventListener('storage'）进行监听\****

//需要监听其他窗口发生事件进行对应操作的窗口

storageChange(keyname,fn,value){//keyname为要存储的名字，fn为触发storage后要执行的方法，value可以自己设置存的值，可以利用这个值跨页面传参

  var val = value ? JSON.stringify(value) : new Date().getTime()

  //为keyname设置默认值为当前时间戳

  localStorage.setItem(keyname,val)

  window.addEventListener('storage',function(e){

​    if(e.key == key){//判断是否是目标值发生改变

​      fn(e.newValue,e.oldValue)//执行fn，返回新值和旧值

​    }

  })

}

storageChange('keyname',function(){

  console.log('keyname的值发生了改变')

})

//其他窗口发生事件，即修改localStorage里key的值

localStorage.setItem('keyname',val)

###### ***\*5.前端做登录注册时提交按钮问题在用ajax传数据给后端时，通常给button按钮绑定js事件\****

<form class="form-horizontal">

	<div class="form-group">

​		<!-- <label for="logname" class="col-sm-2 control-label">账号</label> -->

		<div class="col-sm-12">

​			<input type="text" class="form-control logname" name="logname" placeholder="输入账号">

​		</div>

​	</div>

	<div class="form-group">

​		<!-- <label for="logpw" class="col-sm-2 control-label">密码</label> -->

		<div class="col-sm-12">

​			<input type="password" class="form-control logpw" name="logpw" placeholder="输入密码">

​		</div>

​	</div>

	<div class="form-group">
	
		<div class="col-sm-12">

​			<button type="button" id="submit" class="btn btn-primary">登陆</button>

​		</div>

​	</div>

</form>

<button type="button" id="reg-link" class="btn btn-link">注册</button>

$("#submit").click(function() {

​	var logname = $(".logname").val();

​	var logpw = $(".logpw").val();

​	console.log('ajax');

​	$.ajax({

​		url: '/process',

​		type: 'post',

​		dataType: 'json',

​		data: {

​				logname: logname,

​				pw: logpw

​			 },

​		success : function(data, status){

​			if (data == 0){

​				$('.title').text('账号或密码错误');

​			}

​			else {

​				console.log(data[0]);

​				window.location.href = "http://127.0.0.1:8888/homepage";

​			}

​		}

​	});

});

这里如果button按钮没有设置type=button的话当点击提交数据时会导致提交数据的时候页面刷新，从而在success里面设置的页面跳转失败，即直接停留在当前页面

###### ***\*6.ajax传输给nodejs后台数据时的数据类型问题\****

这里数据库用的是mongodb

当我在前端input填入信息并提交，用post的方法传入nodejs后台的时候，传入的参数均是字符串string类型，例如abcd、abcd123、1234567等数据均为string类型，这就导致了当我直接在后台拿这些数据去跟数据库比对的时候，abcd和abcd123这两种可以比对成功，而1234567这样的纯数字字符串则比对失败。

var user_name = req.body.logname;

var password = req.body.pw;

MongoClient.connect(url, {useNewUrlParser:true}, function(err, db){

​	if (err) throw err;

​	var dbo = db.db('student')

​	var whereStr = {'admin': user_name, 'pw': password}//查询条件

​	dbo.collection('class1').find(whereStr).toArray(function(err, res){

​		if (err) throw err;

​		//console.log(res[0]['admin']);

​		if (res != ''){

​			console.log('登陆成功');

​			console.log(res);

​			response.send(JSON.stringify(res));

​			// response.status(200).send(res);

​			response.end();

​		}

​		else{

​			console.log('账号或密码错误');

​			response.send("0");

​			response.end();

​		}

​		db.close();

​	})

})

像这样，直接用req.body.logname拿到的post参数去跟数据库比对

所以，当传入的参数是纯数字的String类型时，应该讲该字符串转为Number类型，再将数据和数据库进行比对

if (!isNaN(user_name)){ //如果传过来的数据是纯数字的字符串

​	user_name = parseInt(user_name); //将数据转为数字类型

}

if (!isNaN(password)){

​	password = parseInt(password);

}

###### ***\*7.用isNaN判断数据是否是非数字值，是则true，不是则false\****

（另加一个很好用的数据类型判断方法，typeof()，typeof(‘abc’)返回String）

## ***\*HTML5\CSS3面试题整理\****

###### ***\*1.Doctype作用? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?\****

  （1）<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。

  （2）严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。

  （3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

  （4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

###### ***\*2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\****

  （1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，

  比如div默认display属性值为“block”，成为“块级”元素；

  span默认display属性值为“inline”，是“行内”元素。  

  （2）行内元素有：a b span input select strong（强调的语气）

   块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p  

  （3）知名的空元素：

   <br><hr><img><link><meta><embed>

###### ***\*3.CSS的盒子模型有几种？各有什么特点？\****

  （1）两种，IE 盒子模型、标准 W3C 盒子模型；

  （2）标准盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).

   IE盒模型：content部分包含了 border 和 pading;

###### ***\*4.link 和@import 的区别是?\****

  （1）link属于HTML标签，而@import是CSS提供的;

  （2）页面被加载的时，link会同时被加载，而@import会等CSS被加载完再加载;

  （3）import只在IE5以上才能识别，而link是HTML标签，无兼容问题;

  （4）link方式的样式的权重 高于@import的权重.

###### ***\*5.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\****

​    1.id选择器（ # myid）

​    2.类选择器（.myclassname）

​    3.标签选择器（div, h1, p）

​    4.相邻选择器（h1 + p）

​    5.子选择器（ul < li）

​    6.后代选择器（li a）

​    7.通配符选择器（ * ）

​    8.属性选择器（a[rel = "external"]）

​    9.伪类选择器（a: hover, li: nth - child）

​    可继承： font-size font-family color, UL LI DL DD DT;

​    不可继承 ：border padding margin width height ;

​    优先级就近原则，样式定义最近者为准;

​    载入样式以最后载入的定位为准;

优先级为:

​    !important >  id > class > tag  

​    important 比内联优先级高

CSS3新增伪类举例：

  p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。

  p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。

  p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。

  p:only-child   选择属于其父元素的唯一子元素的每个 <p> 元素。

  p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。

  :enabled、:disabled 控制表单控件的禁用状态。

  :checked，单选框或复选框被选中。

###### ***\*6.如何居中div,如何居中一个浮动元素?\****

给div设置一个宽度，然后添加margin:0 auto属性

  div{width:200px;margin:0 auto;}  

居中一个浮动元素

   .div {

   Width:500px ; height:300px;//高度可以不设

   Margin: -150px 0 0 -250px;

   position:relative;相对定位

   background-color:pink;//方便看效果

   left:50%;

   top:50%;

  }

###### ***\*7.浏览器的内核分别是什么? 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？\****

   \1. IE浏览器的内核Trident、 firefox的Gecko、Safari的Webkit、Chroma/Opera的Blink；

   2.浏览器默认的margin和padding不同。解决方案是加一个全局的 *{margin:0;padding:0;}来统一。

   IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin 比设置的大。

   浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

   这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 — —_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)渐进识别的方式，从总体中逐渐排除局部。

   3.首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。

   接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

​     .bb{

​      background-color:#f1ee18;/*所有识别*/

​     .background-color:#00deff\9; /*IE6、7、8识别*/

​     +background-color:#a200ff;/*IE6、7识别*/

​     _background-color:#1e0bd1;/*IE6识别*/

​     }

  4.IE下,可以使用获取常规属性的方法来获取自定义属性,

​    解决方法:统一通过getAttribute()获取自定义属性.

   IE下,even对象有x,y属性,但是没有pageX,pageY属性;

   Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.

   （条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

   Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,

   可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.

   超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover 和active了解决方法是改变CSS属性的排列顺序:

   L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}

###### ***\*8.css属性那些有继承性？哪些没有？\****

有继承性的属性：color ,font-size,font-weight

没有继承性的属性：border,width,height

###### ***\*9.如果盒子都为浮动，父类会没有高度，如何解决\****

 解决方法：(1)给父类设置相应的高度

  (2)创建一个孩子对象，设置清除浮动

   (3) 设置父类为overflow：hidden

(4)用before和after动态添加

###### ***\*10.visibility和display 的隐藏有什么区别？\****

display隐藏对象，会清空面积；visibility隐藏对象还会占有以前的面积

###### ***\*11.伪类的写作顺序？\****

hover必须在link、visited之后，active必须在hover之后

Link,visited,hover,active

###### ***\*12.border和outline的区别\****

1.outlinte显示在border之外

2.border会占像素，outline没有面积

3.outline低版本浏览器不支持

###### ***\*13.iframe的缺点？如何解决？\****

1.iframe会影响页面的onload（加载）事件

2.iframe和主页共享连接池，而浏览器对相同域的链接有限制，所以影响页面的并行加载

解决：使用时通过js动态调用给iframe添加src路径，可以避免以上两个问题

###### ***\*14\*******\*.html5\CSS3有哪些新特性、移除了那些元素？\****

1.语意化更好的内容元素，比如 article、footer、header、nav

  表单控件，date、time、email、url

 CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器， 多背景

  2.center，font,u，frame，frameset

###### ***\*15.你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计？\****

1.首先划分成头部、body、脚部.......

实现效果图是最基本的工作，精确到2px；

  与设计师，产品经理的沟通和项目的参与

  做好的页面结构，页面重构和用户体验

  处理hack，兼容、写出优美的代码格式

  针对服务器的优化、支持 HTML5标签。

2.

<style>

​    *{padding: 0;margin: 0;}

​    .header{width: 100%;height: 300px;background-color: red;}

​    .left,.right{width: 50%;float: left;height: 300px;}

​    .left{background-color: green;}

​    .right{background-color: yellow;}

  </style>

<div class="header">上</div>

<div class="left">左</div>

<div class="right">右</div>

###### ***\*16.常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？\****

  1.使用率较高的框架有jQuery、YUI、Prototype、Dojo、Ext.js、Mootools等。尤其是jQuery，超过91%。

   轻量级框架有Modernizr、underscore.js、backbone.js、Raphael.js等。

 （理解这些框架的功能、性能、设计原理）

  \2. WebStorm 、Eclipse、IETester、Photoshop、PhpStorm、MySQL。

  3。 城市选择插件，汽车型号选择插件、幻灯片插件。弹出层。（写过开源程序，加载器，js引擎更好）

###### ***\*17.列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？\****

  1.block 象块类型元素一样显示。

   none 缺省值。向行内元素类型一样显示。

   inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。

   list-item 象块类型元素一样显示，并添加样式列表标记。

 2.absolute生成绝对定位的元素，相对于static以外的父元素进行定位。

  fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。

  relative生成相对定位的元素，相对于其正常位置进行定位。

  static  默认值。没有定位，忽略top, bottom, left, right声明。

  inherit 规定从父元素继承 position 属性的值。

###### ***\*18.页面重构怎么操作？\****

  编写 CSS、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。

###### ***\*19.如何理解语义化？\****

  html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；

在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。

  搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。

使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

###### ***\*20.为什么要初始化CSS样式？如何初始化？\****

  1.因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

  2.最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）

  淘宝的样式初始化：

  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }

  body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }

  h1, h2, h3, h4, h5, h6{ font-size:100%; }

  address, cite, dfn, em, var { font-style:normal; }

  code, kbd, pre, samp { font-family:couriernew, courier, monospace; }

  small{ font-size:12px; }

  ul, ol { list-style:none; }

  a { text-decoration:none; }

  a:hover { text-decoration:underline; }

  sup { vertical-align:text-top; }

  sub{ vertical-align:text-bottom; }

  legend { color:#000; }

  fieldset, img { border:0; }

  button, input, select, textarea { font-size:100%; }

table { border-collapse:collapse; border-spacing:0; }

Img{border:none}

###### ***\*21.描述一段语义的html代码吧\****

  HTML5中新增加的很多标签（如：<article>、<nav>、<header>和<footer>等）就是基于语义化设计原则

例如：<div id="header">

​     <h1>标题< /h1>

​     <h2>专注Web前端技术< /h2>

​       </div>

###### ***\*22.语义 HTML 具有哪些特性？\****

文字包裹在元素中，用以反映内容。例如：

段落包含在 <p> 元素中。

顺序表包含在<ol>元素中。

从其他来源引用的大型文字块包含在<blockquote>元素中。

HTML 元素不能用作语义用途以外的其他目的。例如：

<h1>包含标题，但并非用于放大文本。

<blockquote>包含大段引述，但并非用于文本缩进。

空白段落元素 ( <p></p> ) 并非用于跳行。

文本并不直接包含任何样式信息。例如：

不使用 <font> 或 <center> 等格式标记。

类或 ID 中不引用颜色或位置。

###### ***\*23.什么叫优雅降级和渐进增强？\****

  优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.

  渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。

###### ***\*24.web标准网站有那些优点？\****

（1） Web标准网站结构和布局分离，使网站的访问和维护更加容易

（2） Web标准网站结构，布局以及页面访问都标准化，使网站能在更多的web标准设备中访问，兼容性更好

（3） Web标准网站语义化更好，语义化的XHTML不仅对用户友好，对搜索引擎也友好。

###### ***\*25.<img>中alt和tittle的区别?\****

alt：图片显示不出来了就提示alt 替代文本

title：鼠标划过图片显示的提示 提示文本

###### ***\*26\*******\*.你是如何优化网页的？\****

1.在书写HTML代码的时候，遵循标签语义化的要求，根据标签的语义性进行选择，如布局使用div、标题使用h系列标签、段落使用p标签等。

2.HTML代码要合理嵌套，一般情况下，行元素当中不能包含块元素，除了段落、标题类型的块元素当中，既能够包含块元素，也能够包含行元素，而段落或标题类的块元素只能够包含文字或行元素。table元素只能够直接包含thead、tbody、tfoot、caption等元素；ul/ol元素只能直接包含li元素；dl元素当中只能直接包含dt和dd元素；form表单当中只能直接包含filedset和legend，不能直接包含input元素。

3.使用外部引入样式表和JS行为代码，实现结构、样式和行为的相分离，降低模块间的耦合度。

4.CSS规则命名中，一律采用小写加中划线的方式，不使用下划线或大写字母，命名采用更简明有语义的英文单词进行组合，进行合理的缩写

5.CSS代码的书写顺序遵循CSS样式的渲染顺序：显示属性-自身属性-文本属性-其他

6.在上线之前进行CSS文件压缩

7.在CSS代码当中，尽量的规避掉不同浏览器的兼容问题，如果实在避免不了，也需要进行合理解决，同时尽可能的少使用hack

8.尽量不在代码中出现没有意义的空标签，对于可以采用空标签清除浮动的代码，可以用其他方法解决，如after伪元素

9.使用背景图合并技术，将多张背景图合并到一张图片上，从而降低页面与服务器之间的请求次数。

10.权衡嵌套层级以及扩展性等多个方面后，在适当位置使用三层嵌套技术。

11.合理的填写html文件中的title、meta等内容，合理书写a标签的title、img标签的title和alt，提升网站的SEO

12.制作网站中的404页面

13.合理控制JS文件的引入位置，提升网站的加载速度。

14.避免class与id重名，对于id名遵循小驼峰命名法。

15.利用对象命名空间、匿名函数、协同命名等方法，尽量避免团队合作时产生的命名冲突。

16.合理利用window.onload或jquery中的$(document).ready，尽量避免全局作用域被污染。

17.合理书写代码注释

18.对于功能类似的代码，进行函数的封装，可以使用面向对象的书写方法，提升代码的复用性和扩展性。

19.合理利用图片预加载和图片懒加载。

20.在DOM节点相关操作上进行优化，如利用变量存储查找到的元素，从而防止每次查找时进行页面重绘、利用文档碎片等。

21.jQuery等插件的合理引用，处理常见的浏览器兼容问题，在标签查找方式上，采用更快的查找方法，如id>标签名>类名的查找。

22.对于AJAX的异步加载，提供加载的相关提醒。

23.在js代码上线之前，后台人员进行相应的JS代码压缩。

###### ***\*27.除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？\****

C，c++，java，php，asp等

###### ***\*28.平时如何管理你的项目，如何设计突发大规模并发架构\****

  先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等

  编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

  标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

  页面进行标注（例如 页面 模块 开始和结束）；

  CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）

  JS 分文件夹存放 命民以该JS 功能为准英文翻译；

  图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

###### ***\*29.你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧\****

Node.js、Mongodb、npmM、MVVM、MEAN

###### ***\*30.移动端（比如：Android IOS）怎么做好用户体验？\****

提高浏览器访问速度，做响应式布局，内容要简单明了，做网页语义化和优化等

###### ***\*31.xhtml和html有什么区别？\****

HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言

最主要的不同：

XHTML 元素必须被正确地嵌套。

XHTML 元素必须被关闭。

标签名必须用小写字母。

XHTML 文档必须拥有根元素。

###### ***\*32.解释css sprites\*******\*（\*******\*精灵图\*******\*）\*******\*，如何使用。\****

Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量

###### ***\*33.清除浮动的几种方式，各自的优缺点\****

1.使用空标签清除浮动 clear:both，会增加无意义的标签

2.使用overflow:auto，空标签元素清除浮动,使用zoom:1用于兼容IE

3.是用afert伪元素清除浮动(用于非IE浏览器)

4.使用overflow:hidden，IE低版本不兼容

###### ***\*34.一个网站制作完成之后，在发布之前，我们会对页面进行测试，测试内容主要包括哪几个方面?\****

页面效果是否美观

链接是否完好

页面功能（如验证、交互等）是否正确

测试不同浏览器的兼容性

###### ***\*35.你都有用过什么布局？瀑布流布局或者流式布局是否有了解？\****

定宽布局：浮动法，定位法，转化表格法

变宽布局：等比变宽，单列固定，优化浮动

瀑布流：多列布局流布局：伸缩盒子旧（弹性盒模型），伸缩盒子新（流布局）

###### ***\*36.是否有接你使用那些版本管理系统，比如Git，SVN等？\****

用过，svn是版本控制器，可以管理代码，不让代码错误覆盖

###### ***\*37.你常用的开发环境是怎样的？比如操作系统，文本编辑器，浏览器，及其他工具等\****

操作系统：xp，window7，window8，window10

硬件环境：4G内存，500G硬盘，i5cpu

文本编辑器：WebStorm，PhpStorm，myeclipse

浏览器：IE，火狐，谷歌，苹果，欧朋

其他工具:Photoshop，IETester，MySQL，截图工具

###### ***\*38.你能描述一下你制作一个网页的工作流程吗？\****

1.美工做图片

2.收集资料（文字、图片、音频、视屏）

3.网上搜集调查

4.色彩搭配，版块布局，风格主题

5.定尺寸，画版块，填充主要内容

6.定义页面内容

7.用户的体验性，动画的制作

8.用户审核

###### ***\*39.你更喜欢在哪个浏览器下进行开发？\****

IE：属于傻瓜式兼容

谷歌：兼用css3属性比较多

###### ***\*40.你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？\****

说出前端的工作内容，畅想未来工作

###### ***\*41.谈谈你认为怎样做能是项目做的更好？\****

例如：

了解客户需求

有很好的设计流程

掌握web前端知识

调整页面兼容性，或者设置响应式页面

优化网页，提高加载速度

设置友好的客户体验性等

###### ***\*42.如何提高用户的体验性？\****

提高浏览器加载速度

能让用户点击的，就不要设计敲键盘

设置友情链接，可以访问外部网站

设置站内搜索，可以关键字查询

页面之间有很好的关联性

可以设置论坛或在线交流问用户解答等

1、在视觉上：设计风格符合目标客户的审美习惯，保持整个站点的视觉一致性，针对目标客户的审美 喜好，进行分析，从而确定网站的总体设计风格。可以从网站LOGO、页面布局、页面色彩、页面大小 、图标使用、广告位、动画效果等方面呈现给用户视听上的体验与舒适性。

2、在操作上：表单提交、按钮设置、点击提示、错误提示、意见反馈、在线搜索、新开窗口、等方面 呈现给用户操作上的体验，强调易用/可用性。

3、在体验上：会员交流、售后反馈、邮件/短信问候、网站地图等方面呈现给用户心理上的体验，强调 友好性

4、在信任感上：联系方式准确有效的地址、电话等联系方式，便于查找。从服务热线、法律声明、帮 助中心、公司介绍、服务保障等方面呈现给用户的信任体验，强调可靠性。

做好用户体验照顾目标受众的需要，分析他们的需要和行业特征。用户体验做好了，客户的粘性就增加了，也会给企业带来利益。

###### ***\*43.一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载\****

1、使用Sprites图片技术

它将一个页面涉及到的所有零星图片都包含到一张大图中去，然后利用CSS技术展现出来。这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了，可以减少了整个网页的图片大小，并且利用CSSSprites能很好地减少网页的http请求，从而大大的提高页面的性能。

2、压缩文本和图片

压缩技术如gzip可以有效减少页面加载的时间。压缩率都可以在大小70%左右。虽然文本压缩用得比较多，但图片的压缩就比较随意，很多都是直接上传，其实还有很大的压缩空间。

3、延迟显示可见区域外的内容

为了确保用户可以更快地看见可见区域的网页可以延迟加载或展现可见区域外的内容，为了避免页面变形，可以使用占位符标签制定正确的高度和宽度。比如WP的jQueryImage LazyLoad插件就可以在用户停留在第一屏的时候，不加载任何第一屏以下的图片信息，只有当用户把鼠标往下滚动的时候，这些图片才开始加载。这样很明显提升可见区域的加载速度，提高用户体验。

4、确保功能图片优先加载

先加载图片再加载其它，会使用户体验感好。但速度不会提升

5、图片格式优化

不恰当的图像格式是一种极为常见的减慢加载速度的罪魁祸首。正确的图片格式可以让图片缩小数倍，如果保存为最佳格式。可以节省大量带宽，减少处理时间时间，大大加快页面加载速。

6、使用 Progressive JPEGs

ProgressiveJPEGs图片是JPEG格式的一个特殊变种，名为“高级JPEG”。在创建高级JPEG文件时，数据是这样安排的：在装入图像时，开始只显示一个模糊的图像，随着数据的装入，图像逐步变得清晰。它相当于交织的GIF格式的图片。

###### ***\*44.get和post的区别？\****

get:会在地址栏里显示传值信息，不安全；针对中文乱码解决能力较差;传值数量有限

post:相对安全,针对中文乱码解决较强，传值数量较多

###### ***\*45.Src和href的区别？\****

  href表示超文本引用，表示与页面有关联的，在link和a等元素使用，src便是来源地址，是页面上必不可少的一部分，是引入，在img，iframe上引用

###### ***\*46.重绘和重排的区别\****

重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

重排必定会引发重绘，但重绘不一定会引发重排

引发重排

1、页面渲染初始化；(无法避免)

2、添加或删除可见的DOM元素；

3、元素位置的改变，或者使用动画；

4、元素尺寸的改变——大小，外边距，边框；

5、浏览器窗口尺寸的变化（resize事件发生时）；

6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；

7、取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,width/height,getComputedStyle(),currentStyle(IE))

重绘发生的情况：

重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）

优化：

1、浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。

（1）直接改变元素的className

（2）display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排；

（3）不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；

（4）使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

（5）将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响

到其他元素；

（6）如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document；

（7）尽量不要使用table布局。

###### ***\*47. px和em和rem的区别\****

px 实际上就是像素，用px设置字体大小时，比较稳定和精确。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。px的缺点是其不能适应浏览器缩放时产生的变化，因此一般不用于响应式网站。

  em 就是根据基准来缩放字体的大小,是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。

rem 相对于根元素 <html> ，这样就意味着，我们只需要在根元素确定一个参考值。rem是CSS3新增的一个相对单位（root em，根em）。

rem特点

rem 相对单位，相对于根元素 <html> ;

相对大小和绝对大小的优点于一身;

修改根元素就成比例地调整所有字体大小;

避免字体大小逐层复合的连锁反应.

###### ***\*48.什么是BFC?\****

BFC全称为块格式化上下文(Block Formatting Context) 。

产生影响：

  根元素或其它包含它的元素

  浮动元素 (元素的 float 不是 none)

  绝对定位元素 (元素具有 position 为 absolute 或 fixed)

  内联块 (元素具有 display: inline-block)

  表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)

  表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)

  具有overflow 且值不是 visible 的块元素，

  display: flow-root

  column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。

  一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。

块格式化上下文对于定位与清除浮动很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动

## ***\*JSvascript面试问题整理\****

###### ***\*1、原型/原型链/构造函数/实例/继承\****

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps1.png) 

构造函数：用 new 操作后面的函数，即便是空函数，结果生成一个实例

原型：声明一个函数时，就自动给该函数增加一个 propotype 属性，指向原型对象（初始化一个空对象），为了实现函数复用

原型链：实例上的 __proto_ 属性指向构造函数的原型对象，最顶端是 Object.prototype，然后再往上就是 null，Object.prototype.__proto__ = null

函数也有 __proto__ 属性，指向 Function.prototype，函数是构造函数 Function 的实例

构造器：原型对象的 constructor 属性，默认指向声明的函数

###### ***\*2、如何实现 new 运算符\****

let new2 = function(func) { 

 //创建一个空对象 o，并且继承构造函数的原型对象  let o = Object.create(func.prototype);

 //执行构造函数，并且上下文 this 指向 o 对象  let k = func.call(o);

 //如果构造函数返回的是对象就返回该对象，否则返回 o 对象  if(typeof k === 'object') {

  return k

 }else {

  return o

 }}

###### ***\*3、有几种方式可以实现继承\****

//借助构造函数实现继承：缺点是父构造函数的原型链继承不了，若要全部继承除非将所有属性和方法定义在构造函数中function Parent1 () {

 this.name = 'parent1';}function Child1 () {

 //这么做的好处是定义在父构造函数中的引用类型的属性，对于子构造函数的每个实例来说是独立的  //并且在子构造函数实例化时，可以给父构造函数传参  Parent.call(this);

 this.type = 'child1';}

//借助原型链实现继承：缺点是继承的引用类型属性是共享的，子构造函数的实例更改会影响其他实例上的这个属性，比如 play 属性function Parent2 () {

 this.name = 'parent2';

 this.play = [1, 2, 3];}function Child2 () {

 this.type = 'Child2';}Child2.prototype = new Parent2();

//组合方式：缺点是会执行两次父构造函数function Child3 () {

 //执行第一次  Parent2.call(this);

 this.type = 'Child3';}Child3.prototype = new Parent2(); //执行第二次//组合优化1，不需要再将定义在父构造函数中的属性和方法再继承一次，只需要继承原型链上的Child3.prototype = Parent2.prototype;//缺点是无法区分一个实例是子函构造函数实例化的还是父构造函数实例化的let s1 = new Child3();//s1.constructor 指向了 Parent2，而不是 Child3，因为 Child3 原型对象的属性 constructor 继承了 Parent2 原型对象上的//如果你强行执行 Child3.prototype.constructor = Child3 的话，也会将 Parent2.prototype.constructor 改成 Child3//组合优化2，通过 Object.create() 创建一个中间对象，将两个原型对象区别开来，并且继承父构造函数的原型链Child3.prototype = Object.create(Parent2.prototype);Child3.prototype.constructor = Child3;//即 Child3.prototype.__proto__ === Parent2.prototype 为 true//如此 Child3.prototype 和 Parent2.prototype 被隔离开，是两个对象，不会相互影响//这种方式为理想继承方式

###### ***\*4、arguments\****

可变参/不定参，为一个类数组，有 length 属性，可以通过循环找到每个参数，可以用 arguments[index] 来找到具体的参数，但是不是真正的数组，如果要转换成真正的数组（意味着可以使用数组方法），可以这么做：

//以 forEach 为例：

Array.prototype.forEach.call(arguments, (item) => {console.log(item);});

[].forEach.call(arguments, () => {});

Array.from(arguments).forEach(() => {}); //直接将 arguments 转换成了数组

当我们给参数命名，是为了增加可读性。

###### ***\*5、数据类型判断\****

判断基本类型（除 null），使用 typeof 运算符:

let num = 1;

typeof num ==='number'; //为 true

//还可以判断是否为 function

typeof func === 'function';

//还可以判断是否为 object

typeof obj === 'object';

判断 null 或者 undefined，直接跟 null 或者 undefined 作比较，num === null

判断数组：

1）arr instanceof Array //返回 true 表示 arr 是数组类型，前提是必须保证由同一个 Array 构造函数生成的实例，如果是另一个 iframe 的话，则不为 true，则即便是数组类型，也得不到正确的结果

2）arr.constructor === Array //问题跟 instanceof 相同，且这个属性是可以被改写的

3）Array.isArray(arr) //一般使用这个方式，不存在上面的问题

4）Object.prototype.toString.call(arr) //必须使用 Object 原型对象上的 toString 方法，而不能使用 Array 重写的 toString 方法，这个方式可以区分函数/数组/对象/null，也没有上面的问题，且兼容性比第三种更好（第三就是这种方式的语法糖，只不过只能判断是否是数组类型，直接使用这种方式可以判断更多类型），这么使用：

Object.prototype.toString.call(arr) === '[object Function]' || '[object Array]' || '[object null]' || '[object Object]' 

PS：instranceof 的作用是判断一个对象是否是另一个对象的实例，其问题除了上面的以外，还有就是只要是原型链上的对象，返回都为 true，因此我们使用 constructor 来判断更精准，但是 constructor 属性是可以被改写的，因此使用第二道面试题中理想继承方式，就可以使用 constructor 来精准判断一个对象是否是另一个对象的实例。

###### ***\*6、作用域链、闭包、作用域\****

作用域即执行环境，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。在 web 浏览器中，全局执行环境被认为是 window 对象。且每个函数都有自己的执行环境，在进入函数时入栈，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在环境的变量对象，最后端，始终是全局执行环境的变量对象。

闭包指的是有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。也就是一个闭包的作用域链上至少包含三个作用域，并且只有闭包才有自由变量（即不是本地定义的，也不是全局变量）

//使用闭包要作内存管理let func = (function() { return function closure() {} })();//会将 closure 函数和它的作用域链赋值给 func 全局变量，外部函数的作用域会一直保存在内存中，直到 closure 函数不存在//为了优化性能，在调用完 func 后应该给 func 变量作解除引用的操作，即 func = null; //让值脱离环境，让垃圾收集器下次运行时将值回收。

###### ***\*7、Ajax的原生写法\****

   function ajax1() {

​    //创建一个 XHR 对象     let oAjax = window.XMLHttpRequest ? (new XMLHttpRequest()) : (new window.ActiveXobject('Microsoft.XMLHTTP'));

​    //返回一个函数，这是函数柯里化操作，不用每次调用 ajax 都判断浏览器环境     //但是会占用更多的内存，因为总是会保存外部函数的作用域     return function(url, fnSucc, fnFaild) {

​     //只要 XHR 对象的 readyState 属性的值发生改变，就触发这个事件      oAjax.onreadystatechange = function() {

​      // readyState 属性是 0-4 的值，当为 4 时，表示已经接收到全部响应数据，并可以在客户端使用       if(oAjax.readyState === 4) {

​       //响应的 HTTP 状态        let s = oAjax.status;

​       if(s === 200 || s === 206 || s === 304) {

​        //将响应主体被返回的文本作为参数传给这个函数，并执行这个函数         if(fnSucc) fnSucc(oAjax.responseText);

​       }else {

​        if(fnFaild) fnFaild(oAjax.status);

​       }

​      }

​     };

​     //启动一个请求，准备发送      oAjax.open('GET', url, true);

​     //发送请求      oAjax.send(null);

​    }

   }

###### ***\*8、对象深拷贝、浅拷贝\****

对象浅拷贝是共用一个引用，因此更改新拷贝的对象时，也会更改原来的对象

对象深拷贝是两个引用，有以下几种方式实现深拷贝：

//使用 Object.assign，只能实现第一层属性的深拷贝

let clone = Object.assign({},obj)

//使用 slice，如果数组中有引用类型的元素的话，只能实现第一层的深拷贝

let clone = arr.slice(0);

//使用 concat，同 slice

let clone = [].concat(arr);

//使用 JSON 对象，无法实现属性值为 function 和 undefined 的拷贝，并且拷贝从原型链继承的值也会有问题，比如 constructor 的值变成了 Object

function deepClone(obj) {

 let _obj = JSON.stringify(obj);

 let clone = JSON.parse(_obj);

 return clone;

}

//使用递归，在不使用库的情况下，这种方式可以实现真正的深层度的拷贝

function deepClone(obj) {

 let clone = Array.isArray(obj) ? [] : {};

 if(obj && typeof obj === 'object') {

  for(let key in obj) {

   if(obj.hasOwnProperty(key) {

​    if(obj[key] && typeof obj[key] === 'object') {

​     clone[key] = deepClone(obj[key]);

​    }else {

​     clone[key] = obj[key];

​    }

   }

  }

 }

 return clone;

}

//通过 JQuery 的 extend 方法

//使用 lodash 函数库

for-in 和 for-of 的区别：







在使用 console.log 这类方法输出对象时会显示内存的最新状态，在同一个 tick 中，即便更改对象是在 console.log 之后，那么输出的对象也是被更改过的对象，因此，如果想输出某个时刻的对象值时，应该进行深拷贝进行输出。

###### ***\*9、图片懒加载、预加载\****

图片懒加载是为了降低一次性的 HTTP 请求数量，当图片很多时，或者同时在线人数较多时，图片懒加载可以起到很好的性能优化的作用。

实现步骤：

1）设置自定义属性 data-src 来存储图片资源；

2）页面初始化或者在滚动时判断图片是否出现在可视区域；

3）在可视区域的话，将自定义属性 data-src 的值赋值给 src 属性。

  class LazyLoad {

   constructor(tag) {

​    this.boundTop = 0;

​    this.clientHeight = 0;

​    this.timer = null;

​    this.aImg = Array.from(document.querySelectorAll(tag));

​    this.init();

   }

   isShow(el) {

​    this.boundTop = el.getBoundingClientRect().top;

​    this.clientHeight = document.documentElement.clientHeight;

​    return this.boundTop <= this.clientHeight - 100;

   }

   canLoad() {

​    for(let i=0;i<this.aImg.length;i++) {

​     let img = this.aImg[i]

​     if(this.isShow(img)) {

​      img.src = img.dataset.src

​      //使用 for 循环是为了在改动数组后来操作 i，使得正确遍历每个元素

​      this.aImg.splice(i, 1)

​      i--      

​     }

​    }

   }

   addEvent() {

​    window.addEventListener('scroll', () => {

​     if(!this.aImg.length && this.timer) return;

​     this.timer = setTimeout(() => {

​      this.canLoad();

​      this.timer = null; 

​     }, 200);

​    });

   }

   init() {

​    this.canLoad();

​    this.addEvent();

   }

  }

  let lazy = new LazyLoad('img');

图片预加载：在需要显示图片之前，就加载完毕，当需要显示图片时，就从缓存中取图片，在图片不是特别多的时候，可以使用预加载。

有多种实现方式，以下为较喜欢的一种：

    <script type="text/javascript">

   //使用 Image 对象来实现

   let imgs = [];

​    function preload() {

​     for(let i=0; i<arguments.length;i++) {

​      //因为有这个对象，所以不用像生成其他对象那样来创建新对象

​      imgs[i] = new Image();

​      //这时就会下载远程图片到本地

​      imgs[i].src = arguments[i];

​     }

​    }

​    preload(

​     "http://img4.imgtn.bdimg.com/it/u=951914923,777131061&fm=26&gp=0.jpg",

​     "http://domain.tld/gallery/image-002.jpg",

​     "http://domain.tld/gallery/image-003.jpg"

​    );

​    //将图片都缓存到了 imgs 数组中，当需要显示它时，就从里面取

  </script>

###### ***\*10、实现页面加载进度条\****

<body>

  <div style="position:fixed;left:0;top:0;z-index:99;width:0%;height:3px;background:#24e1b6;" id="bar"></div>

  <img src="./img/1.png" />

  <img src="./img/2.png" />

  <img src="./img/3.png" />

  <img src="./img/4.png" />

  <img src="./img/5.png" />

</body>

<script>

 (function(){

  let count = 0;

  let script = ['./js/lottie.js', './js/1.js', './js/2.js', './js/3.js'];

  let link = ['./css/1.css', './css/2.css', './css/3.css', './css/4.css', './css/5.css'];

  let img = document.querySelectorAll('img');

  let num = img.length + script.length + link.length;

  for(let i1 = 0, len1 = img.length; i1 < len1; i1++) {

   (function(j1){

​    img[j1].onload = function () {

​     count++;

​     console.log('img=' + count);

​     document.querySelector('#bar').style.width = (count / num) * 100 + '%';

​    };

   })(i1);

  }

  for(let i2 = 0, len2 = script.length; i2 < len2; i2++) {

   //这里使用立即执行函数，是让这些变量成为临时变量，而不是全局变量，全局对象以参数的形式传入，即修改参数不会污染全局变量

   (function(j2){

​    let scriptE = document.createElement('script');

​    scriptE.src = script[j2];

​    scriptE.onload = function () {

​     count++;

​     console.log('script=' + count);

​     document.querySelector('#bar').style.width = (count / num) * 100 + '%';

​    };

​    document.head.appendChild(scriptE);

   })(i2);

  }

  for(let i3 = 0, len3 = link.length; i3 < len3; i3++) {

   (function(j3){

​    let linkE = document.createElement('link');

​    linkE.href = link[j3];

​    linkE.rel = 'stylesheet';

​    linkE.onload = function () {

​     count++;

​     console.log('script=' + count);

​     document.querySelector('#bar').style.width = (count / num) * 100 + '%';

​    };

​    document.head.appendChild(linkE);

   })(i3);

  }

 })();

</script>

如果是 Ajax 请求，那么就使用 XHR 的 progress 事件，事件处理程序接受一个 event 参数，这个参数有三个属性：

lengthComputabel：表示进度信息是否可用，为一个布尔值；

potion：表示已经接收的字节数；

totalSize：便是根据 Content-Length 响应头部确定的预期字节数，即需要加载的总字节数

###### ***\*11、this 关键字\****

在全局环境中，this 指向 window 对象，ES5 函数中，this 对象是在运行时基于函数的执行环境（变量对象，如全局是 window），匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window（在非严格模式下），在严格模式下 this 指向的是 undefined，为了在严格模式下，this 重新指向 window，可以使用非直接调用 eval 的方式，如 (0, eval)('this')，使用了逗号运算符，括号前面会返回 eval，但是和直接调用的区别就是在严格模式下 this 指向不一样。ES6 的箭头函数中，this 对象是在函数定义的执行环境。

###### ***\*12、函数式编程\****

函数式编程中的函数指的数学概念中的函数，即自变量的映射，得到的结果由输入的值决定，不依赖于其他状态，是声明式（依赖于表达式），而非命令式，组合纯函数来构建软件的编程方式。

###### ***\*13、手动实现 parseInt\****

几乎与原生 parseInt 的结果一样，如果有不同的结果，请一定留言告诉我

  function compare(str, radix) {

   let code = str.toUpperCase().charCodeAt(0),

​    num;

   if(radix >= 11 && radix <= 36) {

​    if(code >= 65 && code <= 90) {

​     num = code - 55;

​    }else {

​     num = code - 48;

​    }

   }else {

​    num = code - 48;

   }

   return num;

  }

  function isHex(first, str) {

   return first === '0' && str[1].toUpperCase() === 'X'

  }

  function _parseInt(str, radix) {

   str = String(str);

   if(typeof str !== 'string') return NaN;

   str = str.trim();

   let first = str[0],

​    sign;

   //处理第一个字符为 '-' || '+' 的情况

   if(first === '-' || first === '+') {

​    sign = str[0];

​    str = str.slice(1);

​    first = str[0];

   }

   //当 radix 不存在或者小于 11 时，第一个字符只能为数字

   if(radix === undefined || radix < 11) {

​    if(isNaN(first)) return NaN;

   }

   

   let reg = /^(0+)/;

   //截取 str 前面符合要求的一段，直到遇到非数字和非字母的字符

   let reg2 = /^[0-9a-z]+/i;

   str = str.match(reg2)[0];

   let len = str.length;

   //在没有第二个参数时或者不是数字时，给第二个参数赋值

   //isNaN('0x12') 会执行 Number('0x12') 可以转换成十进制

   if(radix === undefined || isNaN(radix)) {

​    if(len === 1) return str;

​    //如果 str 是十六进制形式，就转换成十进制

​    if(isHex(first, str)) {

​     return Number(str);

​    }else {

​     radix = 10;

​    }

   }else {

​    //如果有第二个参数，并且是数字，要处理第二个参数

​    radix = String(radix);

​    //如果有小数点，取小数点前面一段，处理不为整数的情况

​    radix = radix.split('.')[0];

​    //如果 radix 等于零的话，就按照 str 来判断 radix 的基数

​    if(radix === '0') {

​     if(isHex(first, str)) {

​      return Number(str);

​     }else {

​      radix = 10;

​     }

​    }

​    //如果 radix 前面有零将零去除，十六进制除外

​    if(radix.length > 1) {

​     let twoR = radix[1].toUpperCase();

​     if(radix[0] === '0' && twoR !== 'X') radix = radix.replace(reg, '');

​    }

​    //如果 radix 是十六进制的字符串类型，也会转变成十进制的数字类型

​    radix = Number(radix);

​    //radix 是否在正确的区间

​    if(radix >= 2 && radix <= 36) {

​     //如果 radix 为 16，且 str 是十六进制形式的话，直接将十六进制转换成十进制

​     if(radix === 16 && isHex(first, str)) return Number(str);

​    }else {

​     //只要 radix 是一个有效的数字，但不在正确的区间里，就返回 NaN

​     return NaN;

​    }

   }

   //去除 str 前面的零

   str = str.replace(reg, '');

   if(str.length === 0) return 0;

   let strArr = str.split(''),

​    numArr = [],

​    result = 0,

​    num;

   for(let i=0; i<strArr.length; i++) {

​    num = compare(strArr[i], radix);

​    if(num < radix) {

​     numArr.push(num);

​    }else {

​     break;

​    }

   }

   let lenN = numArr.length;

   if(lenN > 0) {

​    numArr.forEach(function(item, index) {

​     result += item * Math.pow(radix, lenN - index -1);

​    });

   }else {

​    //str 开头有零的话要返回零

​    return first === '0' ? 0 : NaN;

   }

   if(sign === '-') result = -result;

   return result;

  }

###### ***\*14、为什么会有同源策略\****

同源策略限制从一个源加载的文档或脚本如何与另一个源的资源进行交互。这是用于隔离潜在恶意文件的关键安全机制。

同源策略：协议相同、域名相同、端口相同，三者都必须相同

什么叫限制：不同源的文档不能操作另一个源的文档，在以下几个方面操作不了：

1）Cookie、localStorage、indexDB 无法读取

2）DOM 无法获得

3）AJAX 请求无法发送

###### ***\*15、怎么判断两个对象是否相等\****

1）判断引用是否为同一个引用；

2）如果是不同引用，判断长度是否相同；

3）通过 Object.getOwnpropertyNames(a) 拿到所有属性，判断是否有相同的属性 key，如果相同，再判断值是否相同。

参考资料

###### ***\*16、事件模型\****

一个完整的事件流分为三个阶段：第一阶段是捕获，第二阶段是目标阶段，第三阶段是目标元素通过冒泡上传到 window 对象。这个过程就是用户和浏览器交互的过程，浏览器通过事件捕获知道了用户的操作，再通过事件冒泡将操作信息传递给浏览器。

//事件捕获的具体流程：

window -> document -> html -> body -> … -> 目标元素

//事件冒泡的流程是反过来的

1）事件委托、代理

事件委托是将事件监听器绑定到父元素上，点击任意一个子元素，通过事件冒泡将事件传给父元素

event.currentTarget  //传回事件绑定的这个元素

event.target //传回被点击的这个元素对象

2）如何让事件先冒泡后捕获

window.addEventListener('click',  func, false); 

//false 为冒泡时触发事件，默认

//true 为捕获时触发事件

//还可以这样写：

el.addEventListener(type, listener, {

  capture: false, // useCapture

  once: false,   // 是否设置单次监听

  passive: false  // 是否让阻止默认行为preventDefault()失效

})

###### ***\*17、window\*******\*7\**** ***\*的 onload 事件和 DOMContentLoaded 事件\****

第一个是当页面所有的资源（图片、音频、视频等）全部加载完毕才会触发

第二个是当 DOM 结构加载完毕就会触发

简单来说，页面的 load 事件会在 DOMContentLoaded 被触发之后才触发。

###### ***\*18、for...in 迭代和 for...of 有什么区别\****

在循环对象属性时使用 for...in，因为会将所有可枚举属性都遍历出来，但是有以下几个问题：

1）将自定义属性也会遍历出来；

2）遍历出来的属性顺序是随机的

在循环数组时使用 for...of，我们可以配合迭代器，可以对复杂的、自定义的数据结构输出我们想要的结果，且不会输出自定义的属性：

  //以 Symbol.iterator 为 key，以函数为值，为对象构建一个迭代器

  Array.prototype[Symbol.iterator] = function () {

​    let arr = [].concat(this);

​    let getFirst = function(array) {

​     return array.shift();

​    };

​    return {     //规定返回一个对象

​     next () {   //规定返回的对象中必须有 next 方法

​      let item = getFirst(arr);

​      if(item) {

​       return {   //规定 next 方法必须返回一个对象，有以下两个属性

​        value: item,  //这里做了隐式类型转换，进行了 toString()

​        done: false

​       };

​      }else {

​       return {

​        done: true

​       };

​      }

​     }

​    }

   };

   let arr = ['a', ['b', 'c'], 2, ['d', 'e', 'f'], 'g', 3, 4];

   function flat() {

​    let r = [];

​    for(let i of arr) {    //调用 for...of 就是内部不断调用了 next()

​     r.push(i);

​    }

​    return r.join(',');

   }

   console.log(flat(arr));

  //结果为：a,b,c,2,d,e,f,g,3,4

  //当然还可以使用递归和类型转换来达到目的

如果想输出带有顺序的对象属性值的话，要配合 Object.keys() 来使用：

let obj = {};

for(let key of Object.keys(obj)) {  //这里 for...of 迭代的是数组

 console.log(obj[key]);

}

在使用它们时，建议加上 let 来使用，且在使用 for...of 时，要注意迭代对象是否是可迭代的对象，即是否有迭代器，对象默认是没有迭代器的，只有数组有迭代器，无法直接使用 for...of。

//比如无法直接迭代对象

let obj = {};

for(let key of obj) {} //会报错

###### ***\*19、函数柯里化\****

函数柯里化是将多参数或者差异化参数转变成单参数或者无差异化参数的一种函数式编程的运算方式。这么做的好处是可以将核心逻辑跟其他逻辑（包括环境判断等只需要一次性操作的逻辑）分离开来，做法是使用一个函数返回一个函数，在第一个函数中执行其他逻辑，并且对差异化参数进行处理，然后返回一个无差异参数且只有核心逻辑代码的函数，以后每次执行都只需要执行这个函数。在 vue.js 源码中大量使用了函数柯里化方式。举一个 ajax 的例子：

   let ajax = (function() {

​    let oAjax = window.XMLHttpRequest ? (new XMLHttpRequest()) : (new window.ActiveXobject('Microsoft.XMLHTTP'));

​    return function(url, fnSucc, fnFaild) {

​     oAjax.onreadystatechange = function() {

​      if(oAjax.readyState === 4) {

​       let s = oAjax.status;

​       if(s === 200 || s === 206 || s === 304) {

​        if(fnSucc) fnSucc(oAjax.responseText);

​       }else {

​        if(fnFaild) fnFaild(oAjax.status);

​       }

​      }

​     };

​     oAjax.open('GET', url, true);

​     oAjax.send(null);

​    }

   })();

   

//如此环境判断只需要执行一次，当然这样又因为使用了闭包，要保存外部函数的作用域，占用更多的内存，所以也这都是有一定的取舍的

###### ***\*20、call，apply，bind 三者用法和区别，原生实现 bind\****

function fn(num1, num2) {

  console.log(num1 + num2);

  console.log(this);

}

fn.call(obj , 100 , 200);  //call 是一个一个传入参数

fn.apply(obj , [100, 200]);  //apply 是传入一个数组

//它们都是将第一个参数替换 fn 函数中的 this 关键字，然后执行 fn 函数

//只是替换 this 关键字，不执行 tempFn 函数

var tempFn = fn.bind(obj, 1, 2);

//在需要执行时，执行这个函数

tempFn();

//原生实现 bind

Function.prototype.bind2 = function(newThis) {

 var aArgs = Array.prototype.slice.call(arguments, 1) //拿到除了newThis之外的预置参数序列

 var that = this

 return function() {

  return that.apply(newThis, aArgs.concat(Array.prototype.slice.call(arguments)))

  //绑定this同时将调用时传递的序列和预置序列进行合并，比如 tempFn(3) 其中 3 就是调用是传递的序列

 }

}

//原生实现 call

   Function.prototype.call2 = function(context, ...arg) {

​    context = context || window;

​    context.fn = this;  //调用 call2 的函数就是 this，比如这里的 show 函数

​    let result = context.fn(...arg); //调用 show 函数，这个函数里面的 this 是执行环境中的对象

​    delete context.fn;   //不要污染 context 对象

​    return result;

   }

   function show (){

​    console.log(this);

   }

   let obj = {haha: '123'}

   show.call2(obj);  //跟原生的 call 还是有差异的，会将对象的 __proto__ 属性也显示出来

   show.call(obj);

###### ***\*21、async/await\****

//await 一般会返回一个 promise 的表达式

//await 只能放在async函数里，await 后面的代码是异步执行的，就像使用了 then 来注册回调函数一样

function doubleAfter2seconds(num) {

  return new Promise((resolve, reject) => {

​    setTimeout(() => {

​      resolve(2 * num)

​    }, 2000);

  } )

}

//aync 函数会返回一个 promise 对象

async function testResult() {

  let result = await doubleAfter2seconds(30);

  console.log(result);

}

testResult();

###### ***\*22、立即执行函数和使用场景\****

通过定一个匿名函数，创建了一个新的函数作用域，该命名空间的变量和方法，不会污染全局的命名空间（反过来也一样）。如果在这个函数作用域中要访问全局对象，将全局对象以参数形式传入进去，虽然函数体内可以直接访问全局对象，但为了不污染全局的命名空间，所以以参数形式传入，那么对这个参数的修改不会污染全局变量。

有多种方式使用立即执行函数：

//一般使用第一种

(function(num) {

 console.log(num);

})(123);

(function(num) {

 console.log(num);

}(123));

!function(num) {

 console.log(num);

}(123);

+function(num) {

 console.log(num);

}(123);

-function(num) {

 console.log(num);

}(123);

//使用运算符 =

let fn = function(num) {

 console.log(num);

}(123);

###### ***\*23、设计模式(要求说出如何实现,应用,优缺点)/单例模式实现\****

































###### ***\*24、iframe的缺点有哪些\****

1）页面太多不好管理；

2）框架个数多的话，会出现上下左右滚动条，会分散访问者的注意力，用户体验度差；

3）代码复杂，不利于搜索引擎；

4）设备兼容性差，一些移动设备无法完全显示框架；

5）增加服务器 HTTP 请求。

###### ***\*25、数组问题\****

1）数组去重 

Arr=[1,12,1,3,41,3,54,12]

arr2=[]

Arr.forEach(item => {

If(arr2.indexOf(item) == -1){ this.arr2.push(item) }

Return arr2

})

2）数组常用方法

3）扁平化数组

4）按数组中各项和特定值差值排序(sort)



###### ***\*26、BOM 属性对象方法\****

BOM 提供了很多对象，用于访问浏览器的功能

window 对象扮演全局对象的角色，所有在全局作用域中声明的变量和函数都会变成 window 对象的属性和方法，以下列出操作浏览器的方法：

窗口关系即框架：

window.frames[0] 每个框架都有自己的全局对象，并且保存在 frames 集合中；

window.parent 指向当前框架的上层框架，如果是当前框架是上层框架，则 parent 就等于自身的 window 对象；

窗口位置：用来确定和修改 window 对象位置的属性和方法

window.screenLeft/screenTop 分别用于表示窗口相对于屏幕（电脑显示屏）左边和上边的位置，在火狐中是 window.screenX/screenY

确定窗口大小：

四个属性：innerWidth innerHeight outerWidth outerHeight，不同浏览器返回的具体值不同，由于有浏览器兼容性问题，选择用：

document.documentElement.clientWidth/clientHeight 用来取得页面视口的大小

导航和打开窗口：

使用 window.open(url, frameName) 方法可以导航到一个特定的 url，也可以打开一个新的浏览器窗口，此方法返回指向新窗口的引用，第二个参数还可以是一个特殊的窗口名称：_self _parent _top _blank

let frame = window.open(url, frameName);

frame.close();

alert(frame.closed); //true

系统对话框：

alert() 只显示 ok 按钮

confirm() 显示 ok 按钮和 cancel 按钮

prompt(文本提示，输入域默认值) 这是一个提示框，显示文本输入域，供用户在其中输入内容

location 对象，提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。其用处不只表现在它保存着当前文档的信息，还表现在它将 url 解析为独立的片段，使开发人员可以通过不同的属性访问这些片段。

hash：url 中包含 '#' 即后面的内容，如果没有则返回空字符串

host：返回服务器名称和端口号（如果有）

hostname：返回不带端口号的服务器名称

href：返回当前加载页面的完整 url

pathname：返回 url 中的目录或文件名

port：返回端口号

protocol：返回页面使用的协议

search：返回 url 中包含 '?' 即后面的内容，即查询字符串

每次修改 location 的属性（hash 除外），页面都会以新 url 重新加载

位置操作：

location.assign(url) 立即打开新 url 并在浏览器的历史记录中生成一条记录。以下方式都是内部调用了这个方法：

window.location = url;

location.href = url;

location.replace(url) 方法导致页面改变，但不会在历史记录中生成新记录，调用这个方法后，用户不能回到前一个页面。

location.reload() 方法没有参数时，会使页面重新加载，如果有缓存就从缓存中获取，如果要强制从服务器重新加载，传入参数 location.reload(true)

navigator 对象，通常用于检测显示网页的浏览器类型，根据浏览器的不同有不同的属性可以用，主要讲下三个通用的又实用的属性：

1）appCodeName 浏览器的名称，除了 IE 浏览器之外，基本都返回："Netscape"

2）online 指明系统是否处于脱机状态，返回布尔值

3）userAgent 返回客户端的完整信息

screen 对象，在编程中用处不大，基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。这些信息经常集中出现在测定客户端能力的站点跟踪工具中。列举一个属性（只有 IE 浏览器支持）：

deviceXDPI：返回显示屏幕的每英寸水平点（像素）数。返回的其实就是分辨率，而那个水平点数中的一点就是一像素，DPI 是显示分辨率的一个比例值，DPI 越高说明分辨率越高，如果安卓 DPI 比率分辨值为 1 的话，苹果必然是 2，苹果的像素高

history 对象保存着用户上网的历史记录，其有一个 length 属性，保存这历史记录的数量

history.go() 方法可以在用户的历史记录中任意跳转，可以向后也可以向前，接收一个整数值作为参数；

还可以传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置，可能前进可能后退，具体要看哪个位置更近，如果不包含该字符串，那么这个方法什么都不做。

可以用 back() 来后退，forward() 来前进

history.pushState(state/null, title/null, url) 和 history.replaceState() ，第二个 API 不会加入到历史记录中，用法和第一个相同，第一个 API 的第三个参数必须是与当前页面处于同一个域，它们的作用是使 url 跳转而无需重新加载页面，不会触发 popstate 事件，只有在执行了 history.back history.forward 以及 history.go，或者点击了浏览器的前进后退或者跳转按钮（双击前进或者后退按钮），就会触发 popstate 事件。

vue 的编程式导航利用了 location.hash 属性以及 window.history 上面两个 API 实现页面跳转但不重新加载页面的效果。

###### ***\*27、服务端渲染\****

服务端渲染指的是后端（比如 JAVA PHP）生成 html 文件，客户端发送 http 请求直接获得 html 文件然后直接显示出来，优点是首屏渲染快，有利于 SEO 搜索引擎，缺点是页面切换慢，因为都要发起 http 请求；

客户端渲染指的是客户端通过 ajax 请求数据，首次渲染通过 http 请求 JS 和 CSS 文件，然后在客户端拼接成 html 文件，再显示出来，优点是页面切换快（通过 JS 渲染，动态更新页面），但首屏渲染慢，且不利于 SEO 搜索引擎，React 和 Vue 等 MVVM 框架都是客户端渲染。

如果对于百度的 SEO 有需求（因为谷歌已经可以支持 JS 动态网页），那么就考虑使用前端同构，指的是原本在客户端生成 html 文件，在中间层 node 环境来生成 html 文件，首屏渲染是在 node 环境生成，之后页面切换还是在客户端，中间层和客户端使用一套 JS 代码，最终都是将虚拟 DOM 转换成 html 文件，因为虚拟 DOM 本质上是一个 JS 对象，所以可以跑在 node 环境。

React 的前端同构的支持框架是 next.js，Vue 的前端同构的支持框架是 nuxt.js，在使用这些框架时，要特别注意 node 环境和客户端环境是不同的，比如说没有 window 对象的，因此使用前端框架会报错，当使用这些框架时，要声明只在客户端渲染，再如引入 npm 包，带有 DOM 操作的，不能用 import 来引入，要使用 require() 方式，总之一套代码在两个环境下运行，会遇到很多坑。因此学习成本也是较高的。

###### ***\*28、垃圾回收机制\****

JS 具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，所需内存的分配以及无用内存的回收完全实现了自动管理。垃圾收集机制的原理：找到那些不再继续使用的变量，然后释放其占用的内存。垃圾收集机制会按照固定的时间间隔周期性地执行这一操作。

垃圾收集机制必须跟踪哪个变量有用哪个变量无用，对于不再有用的变量打上标记，以备将来收回其占用的内存。

JS 中最常用的跟踪方法是标记清除，当函数执行完后，就会给局部变量打上“离开环境”的标记（除了闭包），在下一次垃圾回收时间到来时就会清除这一块内存，手动将一个有值的变量赋值为 null，也是让这个值离开环境，也可以释放内存。

还有一种跟踪方法是引用计数，这会引起循环引用的问题，但现在所有的浏览器都使用了标记清除式的垃圾回收机制，所以不用考虑这个问题了。

###### ***\*29、eventloop\****

1）进程和线程

进程是一个程序完成的过程 = CPU 加载上下文 + CPU 执行 + CPU 保存上下文

线程是构成一个程序的任务组合，在 CPU 执行阶段就是执行这一个一个任务

不同进程间数据很难共享，不同线程间数据容易共享

进程可以拓展到多机（多进程），线程最多适合多核（多线程），多核中可以开启多进程，比如浏览器打开一个新的页面（除了多个空白页面外），就会创建一个进程

某个线程使用某些共享内存时，可以上一把“互斥锁”，其他线程只能排队等待，防止多线程同时读取某一块内存区域

某些内存区域只能供给固定的数目线程使用，其他线程排队等待，这叫“信号量“，保证多线程不会互相冲突

2）任务队列

JS 是单线程的，即同一时间只能完成一个任务

任务队列也可以叫异步队列，当一个事件被触发时，就会将回调函数体扔进这个任务队列中，当运行栈的同步任务执行完毕时（一个 tick 完成），就会去任务队列中取异步任务，然后执行（此时为下一个 tick）。所以 JS 遇到一个异步任务时会挂起，而不是立即执行。

###### ***\*30、如何快速让字符串变成以千为精度的数字\****

我也不知道理解题目是否到位，应该是为了考 Number() 的精准度的问题，代码如下：

(Number('12.69598')*1000).toFixed(0)

//Number('12.69598')*1000 得到的结果为 12695.970000000001

//通过 toFixed() 完全去除小数点

## ***\*八、HTTP面试问题整理\****

###### ***\*Http与Https的区别：\****

HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头

HTTP 是不安全的，而 HTTPS 是安全的

HTTP 标准端口是80 ，而 HTTPS 的标准端口是443

在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层

HTTP 无法加密，而HTTPS 对传输的数据进行加密

HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

###### ***\*什么是Http协议无状态协议?怎么解决Http协议无状态协议?\****

无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息

也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。

###### ***\*URI和URL的区别\****

URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。

Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的

URI一般由三部组成：

①访问资源的命名机制

②存放资源的主机名

③资源自身的名称，由路径表示，着重强调于资源。

URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。

采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：

①协议(或称为服务方式)

②存有该资源的主机IP地址(有时也包括端口号)

③主机资源的具体地址。如目录和文件名等

URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。

URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。

在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。

相反的是，URL类可以打开一个到达资源的流。

###### ***\*常用的HTTP方法有哪些？\****

GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器

POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。

PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。

HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。

DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。

OPTIONS：查询相应URI支持的HTTP方法。

HTTP请求报文与响应报文格式

HTTP请求报文与响应报文格式

请求报文包含四部分：

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps2.jpg) 

a、请求行：包含请求方法、URI、HTTP版本信息

b、请求首部字段

c、请求内容实体

d、空行

响应报文包含四部分：

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps3.jpg) 

a、状态行：包含HTTP版本、状态码、状态码的原因短语

b、响应首部字段

c、响应内容实体

d、空行

常见的首部：

通用首部字段（请求报文与响应报文都会使用的首部字段）

Date：创建报文时间

Connection：连接的管理

Cache-Control：缓存的控制

Transfer-Encoding：报文主体的传输编码方式

请求首部字段（请求报文会使用的首部字段）

Host：请求资源所在服务器

Accept：可处理的媒体类型

Accept-Charset：可接收的字符集

Accept-Encoding：可接受的内容编码

Accept-Language：可接受的自然语言

响应首部字段（响应报文会使用的首部字段）

Accept-Ranges：可接受的字节范围

Location：令客户端重新定向到的URI

Server：HTTP服务器的安装信息

实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）

Allow：资源可支持的HTTP方法

Content-Type：实体主类的类型

Content-Encoding：实体主体适用的编码方式

Content-Language：实体主体的自然语言

Content-Length：实体主体的的字节数

Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

###### ***\*HTTPS工作原理\****

一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；

二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；

三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；

四、发送给服务端，此时只有服务端（RSA私钥）能解密。

五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps4.jpg)![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps5.jpg) 

具体的参考链接：

一次完整的HTTP请求所经历的7个步骤

一次完整的HTTP请求所经历的7个步骤

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

建立TCP连接

在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。

Web浏览器发送请求头

浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

Web服务器应答

客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

Web服务器发送应答头

正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

Web服务器向浏览器发送数据

Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

Web服务器关闭TCP连接

一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

Connection:keep-alive

TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接

最具体的HTTP请求过程：

###### ***\*常见的HTTP相应状态码\****

200：请求被正常处理

204：请求被受理但没有资源可以返回

206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。

301：永久性重定向

302：临时重定向

303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上

304：发送附带条件的请求时，条件不满足时返回，与重定向无关

307：临时重定向，与302类似，只是强制要求使用POST方法

400：请求报文语法有误，服务器无法识别

401：请求需要认证

403：请求的对应资源禁止被访问

404：服务器无法找到对应资源

500：服务器内部错误

503：服务器正忙

###### ***\*HTTP1.1版本新特性\****

a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求

b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应

c、断点续传

实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。

###### ***\*HTTP优化方案\****

我下面就简要概括一下：

TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。

内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。

压缩：将文本数据进行压缩，减少带宽

SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速

TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。

## ***\*九、ES6面试问题整理\**** 

###### ***\*es5和es6的区别，说一下你所知道的es6\****

ECMAScript5，即ES5，是ECMAScript的第五次修订，于2009年完成标准化

ECMAScript6，即ES6，是ECMAScript的第六次修订，于2015年完成，也称ES2015

ES6是继ES5之后的一次改进，相对于ES5更加简洁，提高了开发效率

###### ***\*ES6新增的一些特性：\****

1.let声明变量和const声明常量，两个都有块级作用域

　　ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明

2.箭头函数

　　ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义

3.模板字符串

　　模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串

4.解构赋值

　　ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值

5.for of循环

　　for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串

6.import、export导入导出

　　ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用

7.set数据结构

　　Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数

8....展开运算符

　　可以将数组或对象里面的值展开；还可以将多个值收集为一个变量

9.修饰器 @

　　decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数

10.class 类的继承

　　ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念

11.async、await

　　使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性

　　async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成

12.promise

　　Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大

13.Symbol

　　Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的

14.Proxy代理

　　使用代理（Proxy）监听对象的操作，然后可以做一些相应事情

###### ***\*2、var、let、const之间的区别\****

　　var声明变量可以重复声明，而let不可以重复声明

　　var是不受限于块级的，而let是受限于块级

　　var会与window相映射（会挂一个属性），而let不与window相映射

　　var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错

　　const声明之后必须赋值，否则会报错

　　const定义不可变的量，改变了就会报错

　　const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

###### ***\*3、使用箭头函数应注意什么？\****

　　（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）

　　（2）不能够使用arguments对象

　　（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误

　　（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

###### ***\*4、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能\****

　　基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定

　　在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)就能解决

类模板字符串的功能

let name = 'web';

let age = 10;

let str = '你好，${name} 已经 ${age}岁了' 

str = str.replace(/\$\{([^}]*)\}/g,function(){ return eval(arguments[1]);

})

console.log(str);//你好，web 已经 10岁了 

###### ***\*5、介绍下 Set、Map的区别？\****

应用场景Set用于数据重组，Map用于数据储存

　　Set：　

　　（1）成员不能重复

　　（2）只有键值没有键名，类似数组

　　（3）可以遍历，方法有add, delete,has

　　Map:

　　（1）本质上是健值对的集合，类似集合

　　（2）可以遍历，可以跟各种数据格式转换

###### ***\*6、ECMAScript 6 怎么写 class ，为何会出现 class？\****

　　ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法

//定义类class Point { 

constructor(x,y){ //构造方法

this.x = x; //this关键字代表实例对象

this.y = y; 

}toString(){ 

return '(' + this.x + ',' + this.y + ')'; 

}}

###### ***\*7、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？\****

　　promise构造函数是同步执行的，then方法是异步执行的

###### ***\*8、setTimeout、Promise、Async/Await 的区别\****

　　事件循环中分为宏任务队列和微任务队列

　　其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行

　　promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行

　　async函数表示函数里面可能会有异步方法，await后面跟一个表达式

　　async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

###### ***\*9、promise有几种状态，什么时候会进入catch？\****

　　三个状态：pending、fulfilled、reject

　　两个过程：padding -> fulfilled、padding -> rejected

　　当pending为rejectd时，会进入catch

###### ***\*10、下面的输出结果是多少\****

const promise = new Promise((resolve, reject) => {

console.log(1);

resolve();

console.log(2);})

promise.then(() => {

console.log(3);})

console.log(4);//1 2 4 3

Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then() 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3

###### ***\*11、使用结构赋值，实现两个变量的值的交换\****

let a = 1;let b = 2;[a,b] = [b,a];

###### ***\*12、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key\****

let name = Symbol('name');

let product = {

[name]:"洗衣机", "price":799 };

Reflect.ownKeys(product);

###### ***\*13、下面Set结构，打印出的size值是多少\****

let s = new Set();

s.add([1]);

s.add([1]);console.log(s.size);//答案：2

两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值

都能存储到Set结构中，所以size为2

###### ***\*14、Promise 中reject 和 catch 处理上有什么区别\****

　　reject 是用来抛出异常，catch 是用来处理异常

　　reject 是 Promise 的方法，而 catch 是 Promise 实例的方法

　　reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch

　　网络异常（比如断网），会直接进入catch而不会进入then的第二个回调

###### ***\*15、使用class 手写一个promise\****

//创建一个Promise的类

class Promise{

constructor(executer){//构造函数constructor里面是个执行器

this.status = 'pending';//默认的状态 pending

this.value = undefined//成功的值默认undefined

this.reason = undefined//失败的值默认undefined

//状态只有在pending时候才能改变

let resolveFn = value =>{ //判断只有等待时才能resolve成功

if(this.status == pending){ this.status = 'resolve'; this.value = value;

}

} //判断只有等待时才能reject失败

let rejectFn = reason =>{ if(this.status == pending){ this.status = 'reject'; this.reason = reason;

}

} try{ //把resolve和reject两个函数传给执行器executer

executer(resolve,reject);

}catch(e){

reject(e);//失败的话进catch

}

}

then(onFufilled,onReject){ //如果状态成功调用onFufilled

if(this.status = 'resolve'){

onFufilled(this.value);

} //如果状态失败调用onReject

if(this.status = 'reject'){

onReject(this.reason);

}

}

} 

###### ***\*16、如何使用Set去重\****

let arr = [12,43,23,43,68,12];let item = [...new Set(arr)];

console.log(item);//[12, 43, 23, 68]

###### ***\*17、将下面for循环改成for of形式\****

let arr = [11,22,33,44,55];let sum = 0; for(let i=0;i<arr.length;i++){

sum += arr[i];}

//答案：let arr = [11,22,33,44,55];let sum = 0; for(value of arr){

sum += value;}

###### ***\*18、理解 async/await以及对Generator的优势\****

　　async await 是用来解决异步的，async函数是Generator函数的语法糖

　　使用关键字async来表示，在函数内部使用 await 来表示异步

　　async函数返回一个 Promise 对象，可以使用then方法添加回调函数

　　当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句

　　async较Generator的优势：

　　　1.内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样

　　　2.更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　

　　　3.更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值

　　　4.返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用

###### ***\*19、forEach、for in、for of三者区别\****

　　forEach更多的用来遍历数组

　　for in 一般常用来遍历对象或json

　　for of数组对象都可以遍历，遍历对象需要通过和Object.keys()

　　for in循环出的是key，for of循环出的是value

###### ***\*20、说一下es6的导入导出模块\****

导入通过import关键字

// 只导入一个import {sum} from "./example.js"

// 导入多个import {sum,multiply,time} from "./exportExample.js"

// 导入一整个模块import * as example from "./exportExample.js"

导出通过export关键字

//可以将export放在任何变量,函数或类声明的前面export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; //也可以使用大括号指定所要输出的一组变量var firstName = 'Michael'; var lastName = 'Jackson'; var year = 1958;export {firstName, lastName, year}; //使用export default时，对应的import语句不需要使用大括号let bosh = function crs(){}export default bosh;import crc from 'crc'; //不使用export default时，对应的import语句需要使用大括号let bosh = function crs(){}export bosh;import {crc} from 'crc';

## ***\*十、VUE面试问题整理\****

###### ***\*1.什么是MVVM？\****

MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

###### ***\*2.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？\****

mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：

场景：数据操作比较多的场景，更加便捷

###### ***\*3.vue的优点是什么？\****

低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。

可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。

独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。

可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

###### ***\*4. 组件之间的传值？\****

父组件与子组件传值 : props

父组件通过标签上面定义传值

子组件通过props方法接受数据

子组件向父组件传递数据 this.$emit(‘functionName’, data)

子组件通过$emit方法传递参数

###### ***\*5.路由之间跳转\****

声明式（标签跳转） 编程式（ js跳转） this.$router.push({name:“/login”})

###### ***\*6.vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？\****

第一步：在components目录新建你的组件文件（indexPage.vue），script一定要export default {}

第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'

第三步：注入到vue的子组件的components属性上面,components:{indexPage}

第四步：在template视图view中使用，

例如有indexPage命名，使用的时候则index-page

###### ***\*7.vue如何实现按需加载配合webpack设置\****

webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。

不进行页面按需加载引入方式：import home from '../../common/home.vue'

进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue')))

###### ***\*8.vuex面试相关\****

（1）vuex是什么？怎么使用？哪种功能场景使用它？

vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

***\*（2）vuex有哪几种属性？\****

有五种，分别是 State、 Getter、Mutation 、Action、 Module

vuex的State特性

A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data

B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新

C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

vuex的Getter特性

A、getters 可以对State进行计算操作，它就是Store的计算属性

B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用

C、 如果一个状态只在一个组件内使用，是可以不用getters

vuex的Mutation特性

Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。

（3）不用Vuex会带来什么问题？

可维护性会下降，想修改数据要维护三个地方；

可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；

增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。

###### ***\*9.v-show和v-if指令的共同点和不同点\****

v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏

v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果

###### ***\*10.如何让CSS只在当前组件中起作用\**** ***\*scoped 添加hasa 属性\****

将当前组件的<style>修改为<style scoped>

###### ***\*11.<keep-alive> </keep-alive>的作用是什么?\****

包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。

###### ***\*12.Vue中引入组件的步骤?\****

1）采用ES6的import ... from ...语法或CommonJS的require()方法引入组件

2）对组件进行注册,代码如下

// 注册Vue.component('my-component', { template:'

A custom component!

'})

3）使用组件<my-component> </my-component>

###### ***\*13.指令v-el的作用是什么?\****

提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例

###### ***\*14.在Vue中使用插件的步骤\****

采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件

使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })

###### ***\*15.请列举出3个Vue中常用的生命周期\**** 

 Created  mounted  updated  destroyed 

###### ***\*函数\****

created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见

mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

activated: keep-alive组件激活时调用

###### ***\*16.active-class是哪个组件的属性？\****

vue-router模块的router-link组件。

###### ***\*17.怎么定义vue-router的动态路由以及如何获取传过来的动态参数？\****

在router目录下的index.js文件中，对path属性加上/:id。

使用router对象的params.id。

###### ***\*18.vue-router有哪几种导航钩子？\****

三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。

第二种：组件内的钩子；

第三种：单独路由独享组件

###### ***\*19.生命周期相关\****

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。

载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

更新前/后：当data变化时，会触发beforeUpdate和updated方法。

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

（1）、什么是vue生命周期

答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

***\*（2）、vue生命周期的作用是什么\****

答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

***\*（3）、vue生命周期总共有几个阶段\****

答：可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后

***\*（4）、第一次页面加载会触发哪几个钩子\****

答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

***\*（5）、DOM 渲染在 哪个周期中就已经完成\****

答：DOM 渲染在 mounted 中就已经完成了。

***\*（6）、简单描述每个周期具体适合哪些场景\****

答：生命周期钩子的一些使用方法：

beforecreate : 可以在这加个loading事件，在加载实例时触发

created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

mounted : 挂载元素，获取到DOM节点

updated : 如果对数据统一处理，在这里写上相应函数

beforeDestroy : 可以做一个确认停止事件的确认框

q: 更新数据后立即操作dom

###### ***\*20.说出至少4种vue当中的指令和它的用法？\****

v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定

###### ***\*21.vue-loader是什么？使用它的用途有哪些？\****

解析.vue文件的一个加载器。

用途：js可以写es6、style样式可以scss或less、template可以加jade等

###### ***\*22.scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\****

答：css的预编译。

使用步骤：

第一步：先装css-loader、node-loader、sass-loader等加载器模块

第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss

第三步：在同一个文件，配置一个module属性

第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”

特性:

可以用变量，例如（$变量名称=值）；

可以用混合器，例如（）

可以嵌套

###### ***\*23.为什么使用key？\****

当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。

###### ***\*24.为什么避免 v-if 和 v-for 用在一起\****

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。

###### ***\*25.VNode是什么？虚拟 DOM是什么？\****

Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。

## ***\*十一、REACT面试问题整理\****

##### ***\*基本知识\****

###### ***\*1. 区分Real DOM和Virtual DOM\****

| Real DOM                       | Virtual DOM                    |
| ------------------------------ | ------------------------------ |
| 1. 更新缓慢。                  | 1. 更新更快。                  |
| 2. 可以直接更新 HTML。         | 2. 无法直接更新 HTML。         |
| 3. 如果元素更新，则创建新DOM。 | 3. 如果元素更新，则更新 JSX 。 |
| 4. DOM操作代价很高。           | 4. DOM 操作非常简单。          |
| 5. 消耗的内存较多。            | 5. 很少的内存消耗。            |

###### ***\*2. 什么是React？\****



React 是 Facebook 在 2011 年开发的前端 JavaScript 库。

它遵循基于组件的方法，有助于构建可重用的UI组件。

它用于开发复杂和交互式的 Web 和移动 UI。

尽管它仅在 2015 年开源，但有一个很大的支持社区。

###### ***\*3. React有什么特点？\****

React的主要功能如下：

它使用虚拟DOM 而不是真正的DOM。

它可以进行服务器端渲染。

它遵循单向数据流或数据绑定。

###### ***\*4. 列出React的一些主要优点。\****

React的一些主要优点是：

它提高了应用的性能

可以方便地在客户端和服务器端使用

由于 JSX，代码的可读性很好

React 很容易与 Meteor，Angular 等其他框架集成

使用React，编写UI测试用例变得非常容易

###### ***\*5. React有哪些限制？\****

React的限制如下：

React 只是一个库，而不是一个完整的框架

它的库非常庞大，需要时间来理解

新手程序员可能很难理解

编码变得复杂，因为它使用内联模板和 JSX

###### ***\*6. 什么是JSX？\****

JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子：

render(){ return( <div> <h1> Hello World from Edureka!!</h1> </div> );}

###### ***\*7. 你了解 Virtual DOM 吗？解释一下它的工作原理。\****

Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。

Virtual DOM 工作过程有三个简单的步骤。

每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps6.jpg) 

然后计算之前 DOM 表示与新表示的之间的差异。

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps7.jpg) 

完成计算后，将只用实际更改的内容更新 real DOM。

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps8.jpg) 

###### ***\*8. 为什么浏览器无法读取JSX？\****

浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。

###### ***\*9. 与 ES5 相比，React 的 ES6 语法有何不同？\****

以下语法是 ES5 与 ES6 中的区别：

1.require 与 import

// ES5var React = require('react');// ES6mport React from 'react';

2.export 与 exports

// ES5module.exports = Component; // ES6export default Component;

3.component 和 function

// ES5var MyComponent = React.createClass({ render: function() { return <h3>Hello Edureka!</h3>; }});// ES6class MyComponent extends React.Component { render() { return <h3>Hello Edureka!</h3>; }}

props// ES5var App = React.createClass({ propTypes: { name: React.PropTypes.string }, render: function() { return <h3>Hello, {this.props.name}!</h3>;}});// ES6class App extends React.Component { render() { return <h3>Hello, {this.props.name}!</h3>; }}state// ES5var App = React.createClass({getInitialState: function() { return { name: 'world' }; }, render: function() { retur <h3>Hello, {this.state.name}!</h3>; });// ES6class App extends React.Component { constructor() { super(); this.state = { name: 'world' }; } render() { return <h3>Hello, {this.state.name}!</h3>; }}

###### ***\*10. React与Angular有何不同？\****

| 主题        | React                | Angular       |
| ----------- | -------------------- | ------------- |
| 1. 体系结构 | 只有 MVC 中的 View   | 完整的 MVC    |
| 2. 渲染     | 可以进行服务器端渲染 | 客户端渲染    |
| 3. DOM      | 使用 virtual DOM     | 使用 real DOM |
| 4. 数据绑定 | 单向数据绑定         | 双向数据绑定  |
| 5. 调试     | 编译时调试           | 运行时调试    |
| 6. 作者     | Facebook             | Google        |

##### ***\*React 组件\****



###### ***\*11. 你怎样理解“在React中，一切都是组件”这句话。\****

组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。

###### ***\*12. 怎样解释 React 中 render() 的目的。\****

每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <form>、<group>、<div> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。

###### ***\*13. 如何将两个或多个组件嵌入到一个组件中？\****

可以通过以下方式将组件嵌入到一个组件中：

class MyComponent extends React.Componentrender(){ return( 

<div> <h1>Hello</h1> <Header/> </div> ); }

}class Header extends React.Component{ render(){ return <h1>Header Component</h1> };}ReactDOM.render(<MyComponent/>, document.getElementById('content'));

###### ***\*14. 什么是 Props?\****

Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。

###### ***\*15. React中的状态是什么？它是如何使用的？\****

状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们。

###### ***\*16. 区分状态和 props\****

| 条件                    | State | Props |
| ----------------------- | ----- | ----- |
| 1. 从父组件中接收初始值 | Yes   | Yes   |
| 2. 父组件可以改变值     | No    | Yes   |
| 3. 在组件中设置默认值   | Yes   | Yes   |
| 4. 在组件的内部变化     | Yes   | No    |
| 5. 设置子组件的初始值   | Yes   | Yes   |
| 6. 在子组件的内部更改   | No    | Yes   |

###### ***\*17. 如何更新组件的状态？\****



可以用 this.setState()更新组件的状态。

class MyComponent extends React.Component { constructor() { super(); this.state = { name: 'Maxx', id: '101' } } render() {

setTimeout(()=>{this.setState({name:'Jaeha',id:'222'})},2000) return ( <div>

<h1>Hello {this.state.name}</h1>

<h2>Your Id is {this.state.id}</h2>

</div> ); } }ReactDOM.render(<MyComponent/>, document.getElementById('content'));

###### ***\*18. React 中的箭头函数是什么？怎么用？\****

箭头函数（=>）是用于编写函数表达式的简短语法。这些函数允许正确绑定组件的上下文，因为在 ES6 中默认下不能使用自动绑定。使用高阶函数时，箭头函数非常有用。

//General wayrender() { return( <MyInput onChange = {this.handleChange.bind(this) } /> );}//With Arrow Functionrender() { return( <MyInput onChange = { (e)=>this.handleOnChange(e) } /> );}

###### ***\*19. 区分有状态和无状态组件。\****

| 有状态组件                                                   | 无状态组件                                      |
| ------------------------------------------------------------ | ----------------------------------------------- |
| 1. 在内存中存储有关组件状态变化的信息                        | 1. 计算组件的内部的状态                         |
| 2. 有权改变状态                                              | 2. 无权改变状态                                 |
| 3. 包含过去、现在和未来可能的状态变化情况                    | 3. 不包含过去，现在和未来可能发生的状态变化情况 |
| 4. 接受无状态组件状态变化要求的通知，然后将 props 发送给他们。 | 4.从有状态组件接收 props 并将其视为回调函数。   |

###### ***\*20. React组件生命周期的阶段是什么？\****



React 组件的生命周期有三个不同的阶段：

初始渲染阶段：这是组件即将开始其生命之旅并进入 DOM 的阶段。

更新阶段：一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。

卸载阶段：是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。

###### ***\*21. 详细解释 React 组件的生命周期方法。\****

一些最重要的生命周期方法是：

componentWillMount() – 在渲染之前执行，在客户端和服务器端都会执行。

componentDidMount() – 仅在第一次渲染后在客户端执行。

componentWillReceiveProps() – 当从父类接收到 props 并且在调用另一个渲染器之前调用。

shouldComponentUpdate() – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true否则返回 false。默认情况下，它返回 false

componentWillUpdate() – 在 DOM 中进行渲染之前调用。

componentDidUpdate() – 在渲染发生后立即调用。componentWillUnmount() – 从 DOM 卸载组件后调用。用于清理内存空间。

###### ***\*22. React中的事件是什么？\****

在 React 中，事件是对鼠标悬停、鼠标单击、按键等特定操作的触发反应。处理这些事件类似于理 DOM 元素中的事件。但是有一些语法差异，如：

用驼峰命名法对事件命名而不是仅使用小写字母。

事件作为函数而不是字符串传递。

###### ***\*事件参数重包含一组特定于事件的属性。每个事件类型都包含自己的属性和行为，只能通过其事件\*******\*处理程序访问。\****

###### ***\*23. 如何在React中创建一个事件？\****

class Display extends React.Component({ show(evt) { // code }, render() { // Render the div with an onClick prop (value is a function) return ( <div onClick={this.show}>Click Me!</div> ); }});

###### ***\*24. React中的合成事件是什么\*******\*？\****

合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。

###### ***\*25. 你对 React 的 refs 有什么了解？\****

Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。

class ReferenceDemo extends React.Component{

display() { const name = this.inputDemo.value;

document.getElementById('disp').innerHTML = name;

}render() { return( <div> Name: <input type="text" ref={input => this.inputDemo = input} /> <button name="Click" onClick={this.display}>Click</button> <h2>Hello <span id="disp"></span> !!!</h2> </div> ); } }

###### ***\*26. 列出一些应该使用 Refs 的情况。\****

以下是应该使用 refs 的情况：

需要管理焦点、选择文本或媒体播放时

触发式动画

与第三方 DOM 库集成

###### ***\*27. 如何模块化 React 中的代码？\****

可以使用 export 和 import 属性来模块化代码。它们有助于在不同的文件中单独编写组件。

//ChildComponent.jsxexport default class ChildComponent extends React.Component { render() { return( <div> <h1>This is a child component</h1>

</div> ); }

}//ParentComponent.jsximport ChildComponent from './childcomponent.js';class ParentComponent extends React.Component { render() { return( <div> <App /> </div> ); }}

###### ***\*28. 如何在 React 中创建表单\****

React 表单类似于 HTML 表单。但是在 React 中，状态包含在组件的 state 属性中，并且只能通过 setState() 更新。因此元素不能直接更新它们的状态，它们的提交是由 JavaScript 函数处理的。此函数可以完全访问用户输入到表单的数据。

handleSubmit(event) { alert('A name was submitted: ' + this.state.value); event.preventDefault();}render() { return ( <form onSubmit={this.handleSubmit}>

<label>Name: <input type="text" value={this.state.value} onChange={this.handleSubmit} /> </label> <input type="submit" value="Submit" /></form>

);}

###### ***\*29. 你对受控组件和非受控组件了解多少？\****

| 受控组件                                       | 非受控组件               |
| ---------------------------------------------- | ------------------------ |
| 1. 没有维持自己的状态                          | 1. 保持着自己的状态      |
| 2.数据由父组件控制                             | 2.数据由 DOM 控制        |
| 3. 通过 props 获取当前值，然后通过回调通知更改 | 3. Refs 用于获取其当前值 |

###### ***\*30. 什么是高阶组件（HOC）？\****



高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。

###### ***\*31. 你能用HOC做什么？\****

HOC可用于许多任务，例如

代码重用，逻辑和引导抽象

渲染劫持

状态抽象和控制

Props 控制

###### ***\*32. 什么是纯组件？\****

纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。

###### ***\*33. React 中 key 的重要性是什么？\****

key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。

##### ***\*React Redux\****

###### ***\*34. MVC框架的主要问题是什么？\****

以下是MVC框架的一些主要问题

对 DOM 操作的代价非常高

程序运行缓慢且效率低下

内存浪费严重

由于循环依赖性，组件模型需要围绕 models 和 views 进行创建

###### ***\*35. 解释一下 Flux\****

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps9.jpg) 

Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。

###### ***\*36. 什么是Redux？\****

Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。

###### ***\*37. Redux遵循的三个原则是什么？\****

单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。

状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。

使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps10.jpg) 

###### ***\*38. 你对“单一事实来源”有什么理解？\****

Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。

###### ***\*39. 列出 Redux 的组件。\****

Redux 由以下组件组成：

Action – 这是一个用来描述发生了什么事情的对象。

Reducer – 这是一个确定状态将如何变化的地方。

Store – 整个程序的状态/对象树保存在Store中。

View – 只显示 Store 提供的数据。

###### ***\*40. 数据如何通过 Redux 流动？\****

![img](file:////private/var/folders/56/63c4j1w56c56r09nnf8h767m0000gn/T/com.kingsoft.wpsoffice.mac/wps-lurenjing/ksohtml//wps11.jpg) 

###### ***\*41. 如何在 Redux 中定义 Action？\****

React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：

function addTodo(text) {

return { type: ADD_TODO, text }}

###### ***\*42. 解释 Reducer 的作用。\****

Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。

###### ***\*43. Store 在 Redux 中的意义是什么？\****

Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。

###### ***\*44. Redux与Flux有何不同？\****

| Flux                               | Redux                            |
| ---------------------------------- | -------------------------------- |
| 1. Store 包含状态和更改逻辑        | 1. Store 和更改逻辑是分开的      |
| 2. 有多个 Store                    | 2. 只有一个 Store                |
| 3. 所有 Store 都互不影响且是平级的 | 3. 带有分层 reducer 的单一 Store |
| 4. 有单一调度器                    | 4. 没有调度器的概念              |
| 5. React 组件订阅 store            | 5. 容器组件是有联系的            |
| 6. 状态是可变的                    | 6. 状态是不可改变的              |

###### ***\*45. Redux 有哪些优点？\****



Redux 的优点如下：

结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态作和应用的其他部分同步的问题。

可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。

服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。

开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。

社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的

组成的大型社区为库的改进做出了贡献，并开发了各种应用。

易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。

组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。

##### ***\*React 路由\****

###### ***\*46. 什么是React 路由？\****

React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。

###### ***\*47. 为什么React Router v4中使用 switch 关键字 ？\****

虽然 <div> 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，<switch> 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。

###### ***\*48. 为什么需要 React 中的路由？\****

Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图

<switch> <route exact path=’/’ component={Home}/>

<route path=’/posts/:id’ component={Newpost}/>

<route path=’/posts’ component={Post}/></switch>

###### ***\*49. 列出 React Router 的优点。\****

几个优点是：就像 React 基于组件一样，在 React Router v4 中，API 是 'All About Components'。可以将 Router 可视化为单个根组件（<BrowserRouter>），其中我们将特定的子路由（<route>）包起来。无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 <BrowserRouter> 组件中。

包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换。

###### ***\*50. React Router与常规路由有何不同？\****

| 主题       | 常规路由                                        | React 路由                       |
| ---------- | ----------------------------------------------- | -------------------------------- |
| 参与的页面 | 每个视图对应一个新文件                          | 只涉及单个HTML页面               |
| URL 更改   | HTTP 请求被发送到服务器并且接收相应的 HTML 页面 | 仅更改历史记录属性               |
| 体验       | 用户实际在每个视图的不同页面切换                | 用户认为自己正在不同的页面间切换 |

[ ](user_cancel)