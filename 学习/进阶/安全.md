#### 4.1 如何提高网站的安全性？

~~~
前端常见安全问题的7个方面：
1. iframe
2. opener
3. CSRF（跨站请求伪造）
4. XSS（跨站脚本攻击）
5. ClickJacking（点击劫持）
6. HSTS（HTTP严格传输安全）
7. CDN劫持
~~~

iframe + ClickJacking

~~~js
嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题，禁止自己的 iframe 中的链接外部网站的JS。
a.如何让自己的网站不被其他网站的 iframe 引用？
// 检测当前网站是否被第三方iframe引用
if (top.location != self.location) {
    top.location.href = 'http://www.baidu.com'
}

b.如何禁用被使用的iframe对当前网站某些操作？
为iframe设置sandbox属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则
- allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等
- allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载
- allow-forms：允许表单提交
- allow-scripts：允许执行脚本文件
- allow-popups：允许浏览器打开新窗口进行跳转
- “”：设置为空时上面所有允许全部禁止
如使用多项用空格分隔。

ClickJacking 点击劫持。一般会利用透明 iframe 覆盖原网页诱导用户进行某些操作达成目的。
在HTTP头中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中, 
- DENY：不能被所有网站嵌套或加载；
- SAMEORIGIN：只能被同域网站嵌套或加载；
- ALLOW-FROM URL：可以被指定网站嵌套或加载。
~~~

opener

~~~js
如果在项目中需要 打开新标签进行跳转一般会有两种方式
1) HTML -> <a target='_blank' href='http://www.baidu.com'>
2) JS   -> window.open('http://www.baidu.com')

这两种方式看起来没有问题，但是存在漏洞。通过这两种方式打开的页面可以使用 window.opener 来访问源页面的 window 对象。
场景：A 页面通过 <a> 或 window.open 方式，打开 B 页面。但是 B 页面存在恶意代码如下：window.opener.location.replace('https://www.baidu.com') 【此代码仅针对打开新标签有效】
此时，用户正在浏览新标签页，但是原来网站的标签页已经被导航到了百度页面。
恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。
即使在跨域状态下 opener 仍可以调用 location.replace 方法。

1) <a target="_blank" href="" rel="noopener noreferrer nofollow">a标签跳转url</a>
 通过 rel 属性进行控制：
 noopener：会将 window.opener 置空，从而源标签页不会进行跳转（存在浏览器兼容问题）
 noreferrer：兼容老浏览器/火狐。禁用HTTP头部Referer属性（后端方式）。
 nofollow：SEO权重优化

2) function openurl(url) {
    var newTab = window.open();
    newTab.opener = null;
    newTab.location = url;
}
~~~

CSRF / XSRF（跨站请求伪造）

~~~
CSRF(Cross Site Request Frogy)跨站请求伪造：与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B对我们的网站A进行伪造请求。
举个例子
- 受害者登录 a.com，并保留了登录凭证（Cookie）
- 攻击者引诱受害者访问了b.com
- b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
- a.com以受害者的名义执行了act=xx
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作

阐述 CSRF 攻击思想：（核心2和3）
1、浏览并登录信任网站（举例：淘宝）
2、登录成功后在浏览器产生信息存储（举例：cookie）
3、用户在没有登出淘宝的情况下，访问危险网站
4、危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品/余额转账）
5、携带刚刚在浏览器产生的信息进行恶意请求
6、淘宝验证请求为合法请求（区分不出是否是该用户发送）
7、达到了恶意目标

攻击类型
- GET型：如在页面的某个 img 中发起一个 get 请求
- POST型：通过自动提交表单到恶意网站
- 链接型：需要诱导用户点击链接

防御措施（推荐添加token / HTTP头自定义属性）
- 涉及到数据修改操作严格使用 post 请求而不是 get 请求
- 同源检测：HTTP 协议中使用 Referer 属性来确定请求来源进行过滤
- 请求地址添加 token ，使黑客无法伪造用户请求
- HTTP 头自定义属性验证（类似上一条）
- 显示验证方式：添加验证码、密码等
~~~

XSS/CSS（跨站脚本攻击）

~~~html
XSS又叫CSS（Cross Site Script），跨站脚本攻击：攻击者在目标网站植入恶意脚本（js / html），用户在浏览器上运行时可以获取用户敏感信息（cookie / session）、持前端逻辑、发送请求、修改web页面以欺骗用户、与其他漏洞相结合形成蠕虫等。
本质是数据被当作程序执行，浏览器遇到 html 中的 script 标签时，会解析并执行其中的js代码。对特殊字符进行转译就好了
vue/react等主流框架已经避免类似问题，vue举例：不能在template中写script标签，无法在js中通过ref或append等方式动态改变或添加script标签

XSS的注入点
- HTML的节点内容或属性
- javascript代码
- 富文本

XSS类型：
存储型（server端，持久，存储到数据库后读取时注入）：
- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。
- 攻击步骤：
  - i）攻击者将恶意代码提交到目标网站的数据库中
  - ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器
  - iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
  - iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作
反射型（Server端，非持久，存储到数据库后读取时注入）
与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上
- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - i）攻击者构造出特殊的 URL，其中包含恶意代码。
  - ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
Dom 型(浏览器端，被执行的恶意脚本会修改页面脚本结构）
DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。
- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - i）攻击者构造出特殊的 URL，其中包含恶意代码。
  - ii）用户打开带有恶意代码的 URL。
  - iii）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码，对用户输入内容和服务端返回内容进行过滤和转译）
- i）对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等
  - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML
- ii）CSP(content security policy，内容安全策略)，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。
CSP可以通过HTTP头部（Content-Security-Policy）或``元素配置页面的内容安全策略，以控制浏览器可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。
CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection
  - 增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)
  - Content-Security-Policy: default-src 'self'-所有内容均来自站点的同一个源（不包括其子域名）
  - Content-Security-Policy: default-src 'self' *.trusted.com-允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)
  - Content-Security-Policy: default-src [https://yideng.com-](https://yideng.com-/)该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档
	- X-XSS-Protection，默认值为1，即默认打开XSS防御，可以防御反射型的XSS，不过作用有限，只能防御注入到HTML的节点内容或属性的XSS，例如URL参数中包含script标签。不建议只依赖此防御手段。
- iii）输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断
- iv）开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- v）验证码
~~~

HSTS（HTTP Strict Transport Security：HTTP严格传输安全）

~~~text
网站接受从 HTTP 请求跳转到 HTTPS 请求的做法，例如我们输入“http://www.baidu.com”或“www.baidu.com”最终都会被302重定向到“https://www.baidu.com”。这就存在安全风险，当我们第一次通过(http://www.baidu.xn--com302[https-149fka9451pilkvxhbu0b6i9b4n8fwnxb2izb35d//www.baidu.com]”。这就存在安全风险，当我们第一次通过) HTTP 或域名进行访问时，302重定向有可能会被劫持，篡改成一个恶意或钓鱼网站。
HSTS：通知浏览器此网站禁止使用 HTTP 方式加载，浏览器应该自动把所有尝试使用 HTTP 的请求自动替换为 HTTPS 进行请求。用户首次访问时并不受 HSTS 保护，因为第一次还未形成链接。我们可以通过 浏览器预置HSTS域名列表或将HSTS信息加入到域名系统记录中，来解决第一次访问的问题。
~~~

CDN劫持

~~~
出于性能考虑，前端应用通常会把一些静态资源存放到CDN（Content Delivery Networks）上面，例如 js 脚本和 style 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。

现在的CDN以支持SRI为荣，script 和 link 标签有了新的属性integrity，这个属性是为了防止校验资源完整性来判断是否被篡改。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。
使用SRI需要两个条件：一是要保证资源同域或开启跨域，二是在中 提供签名以供校验。

integrity 属性分为两个部分，第一部分是指定哈希值的生成算法（例：sha384），第二部分是经过编码的实际哈希值，两者之前用一个短横(-)来分隔
~~~

#### 4.2 url编码

~~~
JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape, decodeURI, decodeURIComponent。

三种方式的特点：
escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。
该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： @*/+。其他所有的字符都会被转义序列替换。

encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：~!*()' 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&=+$,#

encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： ~!*()'。其他字符（比如 ：;/?:@&=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。

提示
提示：请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号(;/?:@&=+$,#)。
~~~

#### 4.3 http和https

~~~
1. HTTP和HTTPS的基本概念
HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS = HTTP + SSL/TLS，如今 SSL 已废弃，所以现在只关注 HTTP + TLS。为了解决 HTTP 协议的问题，HTTPS 引入了数据加密和身份验证机制。在开始传输数据之前，通过安全可靠的 TLS 协议进行加密，从而保证后续加密传输数据的安全性。

TLS 协议：传输层安全性协议（Transport Layer Security，TLS）及其前身安全套接层（Secure Sockets Layer，SSL）是一种安全协议，目的是为了保证网络通信安全和数据完整性。
受 TLS 协议保护的通信过程：先对传输的数据进行了加密（使用对称加密算法）。并且对称加密的密钥是为每一个连接唯一生成的（基于 TLS 握手阶段协商的加密算法和共享密钥），然后发送的每条消息都会通过消息验证码（Message authentication code, MAC），来进行消息完整性检查，最后还可以使用公钥对通信双方进行身份验证

Https的作用
- 内容加密 建立一个信息安全通道，来保证数据传输的安全；
- 身份认证 确认网站的真实性
- 数据完整性 防止内容被第三方冒充或者篡改

2.HTTP与HTTPS有什么区别？
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：
1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
~~~

#### 5.15 https加密解密流程

~~~
1. 客户端发起HTTPS请求 用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。
2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4. 客户端解析证书 这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个随机值。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6. 服务端解密信息 服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7. 传输加密后的信息 这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。
8. 客户端解密信息 客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。
~~~

#### 5.41 介绍下 HTTPS 中间人攻击

~~~
中间人攻击过程如下：
1. 服务器向客户端发送公钥；
2. 攻击者截获公钥，保留在自己手上；
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端；
4. 客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；
6. 同时生成假的加密 hash 值，发给服务器；
7. 服务器用私钥解密获得假秘钥；
8. 服务器用假秘钥加密传输信息；

防范方法：服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。
~~~

#### 5.42 SSL 连接断开后如何恢复？

~~~
Session ID
每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的密钥，而不用重新生成一把。

Session Ticket
session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。
~~~

#### 4.5 非对称加密和对称加密，具体怎么实现的

~~~
对称加密：在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。
非对称加密：指加密和解密使用不同密钥的加密算法。非对称加密算法需要两个密钥：公钥（publickey）私钥（privatekey）。
公钥与私钥是一对存在，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用密钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
~~~

**1、对称加密算法的缺点**

~~~
1、要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商；
2、密钥的数目难于管理。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流；
3、对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；
4、对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。
~~~

**2、两种加密体制的特点**

~~~
非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。

对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥，所以保证其安全性就是保证密钥的安全。而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。

假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。

如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得 十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以通过"信息发送者的公钥"来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比对称加密慢上1000倍。

非对称的好处显而易见，非对称加密体系不要求通信双方事先传递密钥或有任何约定就能完成保密通信，并且密钥管理方便，可实现防止假冒和抵赖，因此，更适合网络通信中的保密通信要求。
~~~

**3、什么是数字证书**

~~~
1 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。
2 它是由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。
3 数字证书绑定了公钥及其持有者的真实身份，它类似于现实生活中的居民身份证，所不同的是数字证书不再是纸质的证照，而是一段含有证书持有者身份信息并经过认证中心审核签发的电子数据，广泛用在电子商务和移动互联网中。
~~~

**4、什么是数字签名**

~~~
4.1 数字签名是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。
> 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改；
> 否则说明信息被修改过，因此数字签名能够验证信息的完整性。
> 如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。
4.2 数字签名是个加密的过程，数字签名验证是个解密的过程。
4.3 数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。
非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。
~~~

**5、非对称加密和对称加密在HTTPS协议中的应用**

~~~
1 浏览器向服务器发出请求，询问对方支持的对称加密算法和非对称加密算法；服务器回应自己支持的算法。
2 浏览器选择双方都支持的加密算法，并请求服务器出示自己的证书；服务器回应自己的证书。
3 浏览器随机产生一个用于本次会话的对称加密的钥匙，并使用服务器证书中附带的公钥对该钥匙进行加密后传递给服务器；服务器为本次会话保持该对称加密的钥匙。第三方不知道服务器的私钥，即使截获了数据也无法解密。非对称加密让任何浏览器都可以与服务器进行加密会话。
4 浏览器使用对称加密的钥匙对请求消息加密后传送给服务器，服务器使用该对称加密的钥匙进行解密；服务器使用对称加密的钥匙对响应消息加密后传送给浏览器，浏览器使用该对称加密的钥匙进行解密。第三方不知道对称加密的钥匙，即使截获了数据也无法解密。对称加密提高了加密速度 。
~~~

**6、完整的非对称加密过程**

~~~
假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：
1. 首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息
2. 你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；
3. 你对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；
4. 你用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上；
5. 你随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；
6. 你用支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝
7. 支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥；
8. 支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；
9. 支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要；
10. 支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；
11. 支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过；
12. 确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。
~~~