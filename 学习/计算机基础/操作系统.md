# 计算机基础

## 1.操作系统

#### 1.1 32位系统和64位系统的区别

**1、处理数据的能力**

32位和64位表示CPU一次能处理的最大位数，理论上来说，64位系统处理的数据效率比32位更高，相当于 单车道和双车道开车似得，双车道单位时间可以有更多的车辆通行。但需要内存跟上，而且程序本身也是64位编译才能发挥64位系统的优势。

**2、支持的内存不同（寻址能力不同）**

64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows Vista x64 Edition支持多达128 GB的内存和多达16 TB的虚拟内存，而32位CPU和操作系统最大只可支持4G内存

**3、软件兼容性**

32位系统无法运行64位软件，64位系统可以安装多数32位软件，以前因为大部分软件都是基于32位架构环境下开发，所以64位系统的兼容性不如32位。但现在64位兼容性也很强了，基本都是可以兼容各类软件了，而且64位的病毒都少了很多。特别是平面设计软件，64位和32位软件在64位系统里区别很大，64位真的快许多。

#### 1.2 线程和进程

**进程（Process）** 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。

**线程（thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

**总结：**

进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。

线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。

#### 1.3 进程间通信

**参考答案**：

**进程通信：**
每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

**管道(pipe)**

管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

**有名管道 (namedpipe)**

有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

**信号量(semaphore)**

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**消息队列(messagequeue)**

消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

**信号 (signal)**

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### 1.4 线程间的通信方式

- 使用全局变量
  主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile

- 使用消息实现通信
  在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。

  1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;
  2)添加消息函数声明afx_msg int OnTSendmsg();
  3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)
  4)添加OnTSM()的实现函数；
  5)在线程函数中添加PostMessage消息Post函数

- 使用事件CEvent类实现线程间通信
  Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。

  1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；
  2)threadStart.SetEvent();使其处于通信状态；
  3)调用WaitForSingleObject()来监视CEvent对象